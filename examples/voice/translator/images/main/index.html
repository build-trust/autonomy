<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>English to Spanish Translator</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, #fef9f3 0%, #fff5eb 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #2d3748;
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: row;
        width: 100%;
        height: 100vh;
        padding: 0;
        max-width: none;
      }

      .transcript-panel {
        width: 70%;
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: 40px;
        background: #fef9f3;
      }

      .voice-panel {
        width: 30%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 40px;
        padding: 40px;
        background: linear-gradient(180deg, #fff5eb 0%, #fef0e0 100%);
        border-left: 1px solid #f5d5b8;
      }

      .header {
        margin-bottom: 20px;
      }

      .header h1 {
        font-size: 24px;
        font-weight: 600;
        color: #c05621;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .header h1 .flag {
        font-size: 28px;
      }

      .header p {
        font-size: 14px;
        color: #975a16;
      }

      .circle-container {
        position: relative;
        width: 200px;
        height: 200px;
      }

      .voice-circle {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow:
          0 10px 40px rgba(237, 137, 54, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.2);
        position: relative;
        border: 3px solid rgba(255, 255, 255, 0.3);
      }

      .voice-circle:hover {
        transform: scale(1.05);
        box-shadow:
          0 15px 50px rgba(237, 137, 54, 0.4),
          inset 0 2px 10px rgba(255, 255, 255, 0.25);
      }

      .voice-circle.listening {
        animation: pulse-listening 2s ease-in-out infinite;
        background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
      }

      .voice-circle.speaking {
        animation: pulse-speaking 1.5s ease-in-out infinite;
        background: linear-gradient(135deg, #fbd38d 0%, #ed8936 100%);
      }

      .voice-circle.processing {
        animation: pulse-processing 1s ease-in-out infinite;
        background: linear-gradient(135deg, #c05621 0%, #dd6b20 100%);
      }

      .voice-circle.delegating {
        animation: pulse-delegating 0.8s ease-in-out infinite;
        background: linear-gradient(135deg, #9c4221 0%, #c05621 100%);
      }

      .waveform-icon {
        width: 80px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .waveform-bar {
        width: 8px;
        background: #ffffff;
        border-radius: 4px;
        transition: all 0.3s ease;
      }

      .waveform-bar:nth-child(1) {
        height: 30px;
      }
      .waveform-bar:nth-child(2) {
        height: 50px;
      }
      .waveform-bar:nth-child(3) {
        height: 40px;
      }
      .waveform-bar:nth-child(4) {
        height: 60px;
      }
      .waveform-bar:nth-child(5) {
        height: 35px;
      }

      .voice-circle:hover .waveform-bar {
        background: #ffffff;
      }

      .voice-circle.listening .waveform-bar,
      .voice-circle.speaking .waveform-bar,
      .voice-circle.processing .waveform-bar,
      .voice-circle.delegating .waveform-bar {
        animation: waveform-pulse 1.2s ease-in-out infinite;
      }

      .voice-circle.listening .waveform-bar:nth-child(1) {
        animation-delay: 0s;
      }
      .voice-circle.listening .waveform-bar:nth-child(2) {
        animation-delay: 0.1s;
      }
      .voice-circle.listening .waveform-bar:nth-child(3) {
        animation-delay: 0.2s;
      }
      .voice-circle.listening .waveform-bar:nth-child(4) {
        animation-delay: 0.3s;
      }
      .voice-circle.listening .waveform-bar:nth-child(5) {
        animation-delay: 0.4s;
      }

      .voice-circle.speaking .waveform-bar:nth-child(1) {
        animation-delay: 0.4s;
      }
      .voice-circle.speaking .waveform-bar:nth-child(2) {
        animation-delay: 0.3s;
      }
      .voice-circle.speaking .waveform-bar:nth-child(3) {
        animation-delay: 0.2s;
      }
      .voice-circle.speaking .waveform-bar:nth-child(4) {
        animation-delay: 0.1s;
      }
      .voice-circle.speaking .waveform-bar:nth-child(5) {
        animation-delay: 0s;
      }

      @keyframes waveform-pulse {
        0%,
        100% {
          transform: scaleY(0.6);
          opacity: 0.7;
        }
        50% {
          transform: scaleY(1.2);
          opacity: 1;
        }
      }

      @keyframes pulse-listening {
        0%,
        100% {
          box-shadow:
            0 10px 40px rgba(237, 137, 54, 0.3),
            0 0 30px rgba(246, 173, 85, 0.25),
            inset 0 2px 10px rgba(255, 255, 255, 0.2);
          transform: scale(1);
        }
        50% {
          box-shadow:
            0 10px 60px rgba(237, 137, 54, 0.45),
            0 0 60px rgba(246, 173, 85, 0.4),
            inset 0 2px 15px rgba(255, 255, 255, 0.25);
          transform: scale(1.05);
        }
      }

      @keyframes pulse-speaking {
        0%,
        100% {
          box-shadow:
            0 10px 40px rgba(251, 211, 141, 0.35),
            0 0 35px rgba(251, 211, 141, 0.35),
            inset 0 2px 10px rgba(255, 255, 255, 0.2);
          transform: scale(1);
        }
        50% {
          box-shadow:
            0 10px 60px rgba(251, 211, 141, 0.5),
            0 0 70px rgba(251, 211, 141, 0.5),
            inset 0 2px 15px rgba(255, 255, 255, 0.25);
          transform: scale(1.08);
        }
      }

      @keyframes pulse-processing {
        0%,
        100% {
          box-shadow:
            0 10px 40px rgba(192, 86, 33, 0.3),
            0 0 25px rgba(192, 86, 33, 0.3),
            inset 0 2px 10px rgba(255, 255, 255, 0.2);
          transform: scale(1);
        }
        50% {
          box-shadow:
            0 10px 60px rgba(192, 86, 33, 0.4),
            0 0 50px rgba(192, 86, 33, 0.4),
            inset 0 2px 15px rgba(255, 255, 255, 0.25);
          transform: scale(1.03);
        }
      }

      @keyframes pulse-delegating {
        0%,
        100% {
          box-shadow:
            0 10px 40px rgba(156, 66, 33, 0.35),
            0 0 30px rgba(156, 66, 33, 0.3),
            inset 0 2px 10px rgba(255, 255, 255, 0.2);
          transform: scale(1);
        }
        50% {
          box-shadow:
            0 10px 60px rgba(156, 66, 33, 0.5),
            0 0 60px rgba(156, 66, 33, 0.45),
            inset 0 2px 15px rgba(255, 255, 255, 0.25);
          transform: scale(1.06);
        }
      }

      .audio-wave {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 240px;
        height: 240px;
        border-radius: 50%;
        border: 2px solid rgba(237, 137, 54, 0.3);
        opacity: 0;
        animation: wave-expand 2s ease-out infinite;
        pointer-events: none;
      }

      .audio-wave:nth-child(2) {
        animation-delay: 0.5s;
      }
      .audio-wave:nth-child(3) {
        animation-delay: 1s;
      }

      .voice-circle.listening ~ .audio-wave,
      .voice-circle.speaking ~ .audio-wave {
        opacity: 1;
      }

      @keyframes wave-expand {
        0% {
          width: 200px;
          height: 200px;
          opacity: 0.8;
        }
        100% {
          width: 300px;
          height: 300px;
          opacity: 0;
        }
      }

      .status-text {
        font-size: 18px;
        color: #c05621;
        text-align: center;
        min-height: 30px;
        transition: all 0.3s ease;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      .status-text.active {
        color: #9c4221;
      }

      .transcript-container {
        width: 100%;
        flex: 1;
        overflow-y: auto;
        background: #ffffff;
        border: 1px solid #f5d5b8;
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 4px 20px rgba(237, 137, 54, 0.1);
      }

      .transcript-item {
        margin-bottom: 16px;
        padding: 16px 20px;
        border-radius: 12px;
        font-size: 15px;
        line-height: 1.6;
      }

      .transcript-item.user {
        background: linear-gradient(135deg, #ebf8ff 0%, #e6fffa 100%);
        margin-left: 20px;
        border-left: 4px solid #3182ce;
      }

      .transcript-item.assistant {
        background: linear-gradient(135deg, #fffaf0 0%, #fef5e7 100%);
        margin-right: 20px;
        border-left: 4px solid #ed8936;
      }

      .transcript-item .role {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        margin-bottom: 8px;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .transcript-item.user .role {
        color: #2b6cb0;
      }

      .transcript-item.assistant .role {
        color: #c05621;
      }

      .transcript-item .text {
        color: #2d3748;
      }

      .controls {
        display: flex;
        gap: 16px;
        margin-top: 20px;
      }

      .control-button {
        padding: 12px 32px;
        background: rgba(237, 137, 54, 0.1);
        border: 2px solid rgba(237, 137, 54, 0.3);
        border-radius: 24px;
        color: #c05621;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      .control-button:hover {
        background: rgba(237, 137, 54, 0.2);
        border-color: rgba(237, 137, 54, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(237, 137, 54, 0.25);
      }

      .control-button.danger {
        border-color: rgba(229, 62, 62, 0.4);
        color: #c53030;
        background: rgba(229, 62, 62, 0.1);
      }

      .control-button.danger:hover {
        background: rgba(229, 62, 62, 0.2);
        border-color: rgba(229, 62, 62, 0.6);
      }

      .connection-status {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #f5d5b8;
        font-weight: 500;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .connection-status.connected {
        border-color: rgba(72, 187, 120, 0.5);
        color: #276749;
        background: rgba(72, 187, 120, 0.1);
      }

      .connection-status.disconnected {
        border-color: rgba(229, 62, 62, 0.5);
        color: #c53030;
        background: rgba(229, 62, 62, 0.1);
      }

      .language-indicator {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 20px;
        background: #ffffff;
        border-radius: 30px;
        box-shadow: 0 2px 15px rgba(237, 137, 54, 0.15);
        font-size: 14px;
        font-weight: 500;
      }

      .language-indicator .arrow {
        color: #ed8936;
        font-size: 18px;
      }

      .language-indicator .lang {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .language-indicator .lang.en {
        color: #2b6cb0;
      }

      .language-indicator .lang.es {
        color: #c05621;
      }

      .tips {
        margin-top: 20px;
        padding: 16px 20px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 12px;
        border: 1px solid #f5d5b8;
      }

      .tips h3 {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #975a16;
        margin-bottom: 10px;
        font-weight: 600;
      }

      .tips ul {
        list-style: none;
        font-size: 13px;
        color: #744210;
      }

      .tips li {
        padding: 4px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tips li::before {
        content: "‚Ä¢";
        color: #ed8936;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="connectionStatus" class="connection-status disconnected">Disconnected</div>

    <div class="container">
      <div class="transcript-panel">
        <div class="header">
          <h1><span class="flag">üá∫üá∏</span> ‚Üí <span class="flag">üá™üá∏</span> Voice Translator</h1>
          <p>Speak in English, hear it in Spanish</p>
        </div>
        <div id="transcriptContainer" class="transcript-container">
          <div style="color: #975a16; font-size: 14px; text-align: center; padding: 40px 20px">
            <div style="font-size: 48px; margin-bottom: 16px">üéôÔ∏è</div>
            <div style="margin-bottom: 8px">Click the orange button to start translating</div>
            <div style="font-size: 12px; color: #a0aec0">Speak English and hear the Spanish translation</div>
          </div>
        </div>
      </div>

      <div class="voice-panel">
        <div class="language-indicator">
          <span class="lang en">üá∫üá∏ English</span>
          <span class="arrow">‚Üí</span>
          <span class="lang es">üá™üá∏ Espa√±ol</span>
        </div>

        <div class="circle-container">
          <button id="voiceCircle" class="voice-circle">
            <div class="waveform-icon">
              <div class="waveform-bar"></div>
              <div class="waveform-bar"></div>
              <div class="waveform-bar"></div>
              <div class="waveform-bar"></div>
              <div class="waveform-bar"></div>
            </div>
          </button>
          <div class="audio-wave"></div>
          <div class="audio-wave"></div>
          <div class="audio-wave"></div>
        </div>

        <div id="status" class="status-text">Click to start</div>

        <div class="controls">
          <button id="endButton" class="control-button danger" style="display: none">End Session</button>
        </div>
      </div>
    </div>

    <script>
      const id = () => Math.random().toString(36).slice(2);
      const visitorId = (localStorage.autonomy_visitor ||= id());

      // State
      let ws = null;
      let mediaStream = null;
      let audioContext = null;
      let workletNode = null;
      let isRecording = false;
      let isConnected = false;

      // Audio playback
      let playbackAudioContext = null;
      let nextPlayTime = 0;
      let scheduledSources = [];
      let isSpeaking = false;

      // DOM elements
      const voiceCircle = document.getElementById("voiceCircle");
      const status = document.getElementById("status");
      const endButton = document.getElementById("endButton");
      const connectionStatus = document.getElementById("connectionStatus");
      const transcriptContainer = document.getElementById("transcriptContainer");

      // Connect to WebSocket
      async function connect() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/agents/translator/voice?scope=${visitorId}&conversation=${id()}`;

        try {
          updateStatus("Connecting...");
          console.log("üîå Connecting to:", wsUrl);

          ws = new WebSocket(wsUrl);

          ws.onopen = () => {
            console.log("‚úÖ WebSocket connected");
            isConnected = true;
            connectionStatus.textContent = "Connected";
            connectionStatus.className = "connection-status connected";
            updateStatus("Click to start translating");

            ws.send(JSON.stringify({ type: "config" }));
          };

          ws.onmessage = async (event) => {
            try {
              const data = JSON.parse(event.data);
              await handleServerMessage(data);
            } catch (err) {
              console.error("‚ùå Error handling message:", err);
            }
          };

          ws.onerror = (error) => {
            console.error("‚ùå WebSocket error:", error);
            updateStatus("Connection error");
          };

          ws.onclose = (event) => {
            console.log("üì™ WebSocket closed:", event.code, event.reason);
            isConnected = false;
            connectionStatus.textContent = "Disconnected";
            connectionStatus.className = "connection-status disconnected";
            if (isRecording) {
              stopRecording();
            }
            updateStatus("Disconnected. Refresh to reconnect.");
          };
        } catch (error) {
          console.error("‚ùå Connection error:", error);
          updateStatus("Failed to connect");
        }
      }

      // Handle messages from server
      async function handleServerMessage(data) {
        const eventType = data.type;

        switch (eventType) {
          case "connected":
            console.log("‚úÖ Server confirmed:", data.message);
            if (data.config) {
              console.log("   Config:", data.config);
            }
            break;

          case "audio":
            isSpeaking = true;
            await playAudioChunk(data.audio);
            setCircleState("speaking");
            updateStatus("Speaking Spanish...");
            break;

          case "transcript":
            if (data.role === "user") {
              console.log("üó£Ô∏è English:", data.text);
              addTranscript("user", data.text);
            } else {
              console.log("üá™üá∏ Spanish:", data.text);
              addTranscript("assistant", data.text);
            }
            break;

          case "transcript_delta":
            break;

          case "speech_started":
            console.log("üé§ Speech started (interrupted=" + data.interrupted + ")");
            if (scheduledSources.length > 0) {
              console.log("üîá Clearing audio queue - user started speaking");
              clearAudioQueue();
            }
            isSpeaking = false;
            setCircleState("listening");
            updateStatus("Listening to English...");
            break;

          case "speech_stopped":
            console.log("‚è∏Ô∏è Speech stopped");
            setCircleState("processing");
            updateStatus("Translating...");
            break;

          case "response_complete":
            console.log("‚úÖ Translation complete");
            isSpeaking = false;
            setCircleState("listening");
            updateStatus("Listening to English...");
            break;

          case "error":
            if (data.error && !data.error.includes("no active response")) {
              console.error("‚ùå Server error:", data.error);
              updateStatus("Error: " + data.error);
            }
            break;
        }
      }

      // Start recording
      async function startRecording() {
        if (!isConnected) {
          updateStatus("Reconnecting...");
          await connect();
          await new Promise((resolve) => setTimeout(resolve, 500));
          if (!isConnected) {
            updateStatus("Failed to connect. Please try again.");
            return;
          }
        }

        if (isRecording) {
          stopRecording();
          return;
        }

        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              sampleRate: 24000,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 24000,
          });

          const workletCode = `
            class PCMProcessor extends AudioWorkletProcessor {
              constructor() {
                super();
                this.bufferSize = 4096;
                this.buffer = new Float32Array(this.bufferSize);
                this.bufferIndex = 0;
              }

              process(inputs, outputs, parameters) {
                const input = inputs[0];
                if (input && input[0]) {
                  const inputData = input[0];
                  for (let i = 0; i < inputData.length; i++) {
                    this.buffer[this.bufferIndex++] = inputData[i];
                    if (this.bufferIndex >= this.bufferSize) {
                      const pcm16 = new Int16Array(this.bufferSize);
                      for (let j = 0; j < this.bufferSize; j++) {
                        const s = Math.max(-1, Math.min(1, this.buffer[j]));
                        pcm16[j] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                      }
                      this.port.postMessage({ pcm16: pcm16.buffer, maxLevel: Math.max(...this.buffer.map(Math.abs)) }, [pcm16.buffer]);
                      this.buffer = new Float32Array(this.bufferSize);
                      this.bufferIndex = 0;
                    }
                  }
                }
                return true;
              }
            }
            registerProcessor('pcm-processor', PCMProcessor);
          `;

          const blob = new Blob([workletCode], { type: "application/javascript" });
          const workletUrl = URL.createObjectURL(blob);

          try {
            await audioContext.audioWorklet.addModule(workletUrl);
          } finally {
            URL.revokeObjectURL(workletUrl);
          }

          const source = audioContext.createMediaStreamSource(mediaStream);
          workletNode = new AudioWorkletNode(audioContext, "pcm-processor");

          workletNode.port.onmessage = (e) => {
            if (!isRecording || !ws || ws.readyState !== WebSocket.OPEN) return;

            const { pcm16, maxLevel } = e.data;

            if (isSpeaking && scheduledSources.length > 0 && maxLevel > 0.02) {
              console.log("‚ö° Client-side interruption detected (level:", maxLevel.toFixed(3), ")");
              clearAudioQueue();
              isSpeaking = false;
              setCircleState("listening");
              updateStatus("Listening to English...");
            }

            const audioBase64 = btoa(String.fromCharCode(...new Uint8Array(pcm16)));
            ws.send(JSON.stringify({ type: "audio", audio: audioBase64 }));
          };

          source.connect(workletNode);
          workletNode.connect(audioContext.destination);

          isRecording = true;
          setCircleState("listening");
          updateStatus("Listening to English...");
          endButton.style.display = "block";

          transcriptContainer.innerHTML =
            '<div style="color: #975a16; font-size: 14px; text-align: center; padding: 20px">üéôÔ∏è Speak in English...</div>';

          console.log("üé§ Recording started");
        } catch (error) {
          console.error("‚ùå Error starting recording:", error);
          updateStatus("Microphone access denied");
        }
      }

      // Stop recording
      function stopRecording() {
        if (!isRecording) return;

        console.log("‚èπÔ∏è Stopping recording");
        isRecording = false;

        if (workletNode) {
          workletNode.disconnect();
          workletNode = null;
        }

        if (mediaStream) {
          mediaStream.getTracks().forEach((track) => track.stop());
          mediaStream = null;
        }

        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }

        setCircleState("");
        updateStatus("Stopped");
        endButton.style.display = "none";

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "close" }));
        }
      }

      // Clear audio queue
      function clearAudioQueue() {
        if (scheduledSources.length === 0) return;

        console.log("üîá Clearing audio queue (" + scheduledSources.length + " sources)");

        scheduledSources.forEach((source) => {
          try {
            source.stop();
          } catch (e) {}
        });
        scheduledSources = [];

        if (playbackAudioContext) {
          nextPlayTime = playbackAudioContext.currentTime;
        }
      }

      // Play audio chunk
      async function playAudioChunk(base64Audio) {
        try {
          if (!playbackAudioContext) {
            playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 24000,
            });
            nextPlayTime = playbackAudioContext.currentTime;
          }

          const audioBytes = Uint8Array.from(atob(base64Audio), (c) => c.charCodeAt(0));
          const pcm16 = new Int16Array(audioBytes.buffer);
          const float32 = new Float32Array(pcm16.length);

          for (let i = 0; i < pcm16.length; i++) {
            float32[i] = pcm16[i] / 32768.0;
          }

          const audioBuffer = playbackAudioContext.createBuffer(1, float32.length, 24000);
          audioBuffer.getChannelData(0).set(float32);

          const source = playbackAudioContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(playbackAudioContext.destination);

          source.onended = () => {
            scheduledSources = scheduledSources.filter((s) => s !== source);
          };
          scheduledSources.push(source);

          if (nextPlayTime < playbackAudioContext.currentTime) {
            nextPlayTime = playbackAudioContext.currentTime;
          }
          source.start(nextPlayTime);
          nextPlayTime += audioBuffer.duration;
        } catch (error) {
          console.error("‚ùå Error playing audio:", error);
        }
      }

      // Set circle visual state
      function setCircleState(state) {
        voiceCircle.classList.remove("listening", "speaking", "processing", "delegating");
        if (state) {
          voiceCircle.classList.add(state);
        }
      }

      // Update status text
      function updateStatus(message) {
        status.textContent = message;
        status.className = "status-text" + (message.includes("...") ? " active" : "");
      }

      // Add transcript to UI
      function addTranscript(role, text) {
        const placeholder = transcriptContainer.querySelector('div[style*="color: #975a16"]');
        if (placeholder) {
          placeholder.remove();
        }

        const item = document.createElement("div");
        item.className = "transcript-item " + role;

        if (role === "user") {
          item.innerHTML = `
            <div class="role">üá∫üá∏ English</div>
            <div class="text">${text}</div>
          `;
        } else {
          item.innerHTML = `
            <div class="role">üá™üá∏ Espa√±ol</div>
            <div class="text">${text}</div>
          `;
        }

        transcriptContainer.appendChild(item);
        transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
      }

      // End session
      function endSession() {
        stopRecording();
        clearAudioQueue();
        scheduledSources = [];
        isSpeaking = false;
        if (ws) {
          ws.close();
          ws = null;
        }
        if (playbackAudioContext) {
          playbackAudioContext.close();
          playbackAudioContext = null;
        }
        updateStatus("Session ended. Click to start again.");
      }

      // Event listeners
      voiceCircle.addEventListener("click", startRecording);
      endButton.addEventListener("click", endSession);

      // Connect on load
      window.addEventListener("load", connect);

      // Cleanup on unload
      window.addEventListener("beforeunload", () => {
        stopRecording();
        if (ws) ws.close();
      });
    </script>
  </body>
</html>
