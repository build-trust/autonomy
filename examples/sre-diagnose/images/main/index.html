<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SRE Incident Diagnosis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background: #0d1117;
        color: #c9d1d9;
        min-height: 100vh;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        color: #58a6ff;
        margin-bottom: 8px;
      }
      .subtitle {
        color: #8b949e;
        margin-bottom: 24px;
      }
      .card {
        background: #161b22;
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 20px;
        margin-bottom: 16px;
      }
      .card h2 {
        margin-top: 0;
        color: #c9d1d9;
        font-size: 18px;
      }
      .form-group {
        margin-bottom: 16px;
      }
      .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #8b949e;
        font-size: 14px;
      }
      .form-group input,
      .form-group textarea,
      .form-group select {
        width: 100%;
        padding: 10px 12px;
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 6px;
        color: #c9d1d9;
        font-size: 14px;
      }
      .form-group textarea {
        min-height: 100px;
        resize: vertical;
      }
      .form-group input:focus,
      .form-group textarea:focus,
      .form-group select:focus {
        outline: none;
        border-color: #58a6ff;
      }
      .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .btn-primary {
        background: #238636;
        color: #fff;
      }
      .btn-primary:hover {
        background: #2ea043;
      }
      .btn-secondary {
        background: #21262d;
        color: #c9d1d9;
        border: 1px solid #30363d;
      }
      .btn-secondary:hover {
        background: #30363d;
      }
      .btn-danger {
        background: #da3633;
        color: #fff;
      }
      .btn-danger:hover {
        background: #f85149;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .sessions-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .session-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 6px;
        margin-bottom: 8px;
      }
      .session-item:hover {
        border-color: #58a6ff;
      }
      .session-info {
        flex: 1;
      }
      .session-id {
        font-family: monospace;
        color: #58a6ff;
        font-size: 14px;
      }
      .session-problem {
        color: #8b949e;
        font-size: 13px;
        margin-top: 4px;
      }
      .status-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
      }
      .status-created {
        background: #1f6feb33;
        color: #58a6ff;
      }
      .status-analyzing {
        background: #a371f733;
        color: #a371f7;
      }
      .status-waiting_for_approval {
        background: #d29922cc;
        color: #0d1117;
      }
      .status-waiting {
        background: #d29922cc;
        color: #0d1117;
      }
      .status-retrieving_credentials {
        background: #1f6feb33;
        color: #58a6ff;
      }
      .status-diagnosing {
        background: #a371f733;
        color: #a371f7;
      }
      .status-approved {
        background: #23863633;
        color: #3fb950;
      }
      .status-denied {
        background: #f8514933;
        color: #f85149;
      }
      .status-completed {
        background: #23863633;
        color: #3fb950;
      }
      .status-error {
        background: #f8514933;
        color: #f85149;
      }
      .phase-progress {
        display: flex;
        gap: 8px;
        margin: 16px 0;
        align-items: center;
      }
      .phase-step {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: #21262d;
        border-radius: 16px;
        font-size: 12px;
        color: #8b949e;
      }
      .phase-step.active {
        background: #1f6feb33;
        color: #58a6ff;
        border: 1px solid #1f6feb;
      }
      .phase-step.completed {
        background: #23863633;
        color: #3fb950;
      }
      .phase-step .icon {
        font-size: 14px;
      }
      .phase-connector {
        width: 20px;
        height: 2px;
        background: #30363d;
      }
      .phase-connector.completed {
        background: #3fb950;
      }
      .credential-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 4px 0;
        font-family: monospace;
        font-size: 12px;
      }
      .credential-item .icon {
        font-size: 14px;
      }
      .credential-item.success {
        color: #3fb950;
      }
      .credential-item.pending {
        color: #8b949e;
      }
      .credential-item.failed {
        color: #f85149;
      }
      .approval-box {
        background: #341a00;
        border: 1px solid #d29922;
        border-radius: 6px;
        padding: 16px;
        margin-top: 16px;
      }
      .approval-box h3 {
        color: #d29922;
        margin-top: 0;
      }
      .approval-actions {
        display: flex;
        gap: 12px;
        margin-top: 12px;
      }
      .findings {
        margin-top: 16px;
      }
      .finding {
        padding: 12px;
        background: #0d1117;
        border-left: 3px solid #58a6ff;
        margin-bottom: 8px;
      }
      .finding-critical {
        border-left-color: #f85149;
      }
      .finding-warning {
        border-left-color: #d29922;
      }
      .finding-info {
        border-left-color: #58a6ff;
      }
      .empty-state {
        text-align: center;
        padding: 40px;
        color: #8b949e;
      }
      .progress-bar-container {
        background: #21262d;
        border-radius: 4px;
        height: 8px;
        margin: 12px 0;
        overflow: hidden;
      }
      .progress-bar {
        background: linear-gradient(90deg, #238636, #3fb950);
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
      }
      .progress-text {
        font-size: 12px;
        color: #8b949e;
        margin-top: 4px;
      }
      .duration-badge {
        display: inline-block;
        padding: 2px 8px;
        background: #21262d;
        border-radius: 4px;
        font-size: 11px;
        color: #8b949e;
        margin-left: 8px;
      }
      .auto-refresh-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
        font-size: 13px;
        color: #8b949e;
      }
      .auto-refresh-toggle input {
        width: 16px;
        height: 16px;
      }
      .version-badge {
        font-size: 11px;
        color: #8b949e;
        padding: 2px 6px;
        background: #21262d;
        border-radius: 4px;
        margin-left: 8px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
      .log-output {
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 12px;
        font-family: monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
      }
      .log-entry {
        margin-bottom: 4px;
      }
      .log-time {
        color: #8b949e;
      }
      .log-info {
        color: #58a6ff;
      }
      .log-warn {
        color: #d29922;
      }
      .log-error {
        color: #f85149;
      }
      .session-banner {
        background: linear-gradient(135deg, #1a1f35 0%, #0d1117 100%);
        border: 2px solid #1f6feb;
        border-radius: 8px;
        padding: 16px 20px;
        margin-bottom: 16px;
        display: none;
      }
      .session-banner .session-id-large {
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        color: #58a6ff;
      }
      .session-banner .session-label {
        font-size: 12px;
        color: #8b949e;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
      }
      .streaming-output {
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 8px;
        padding: 16px;
        margin-top: 16px;
        font-size: 14px;
        line-height: 1.6;
        min-height: 100px;
        max-height: 400px;
        overflow-y: auto;
        display: none;
      }
      .streaming-output .cursor {
        display: inline-block;
        width: 8px;
        height: 16px;
        background: #58a6ff;
        animation: blink 1s infinite;
        vertical-align: text-bottom;
        margin-left: 2px;
      }
      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      /* === Agent Graph Visualization Styles === */
      .main-layout {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 16px;
        margin-top: 16px;
      }
      @media (max-width: 1200px) {
        .main-layout {
          grid-template-columns: 1fr;
        }
      }
      .graph-panel {
        background: #161b22;
        border: 1px solid #30363d;
        border-radius: 6px;
        overflow: hidden;
        display: none;
      }
      .graph-panel.visible {
        display: block;
      }
      .graph-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: #21262d;
        border-bottom: 1px solid #30363d;
      }
      .graph-header h3 {
        margin: 0;
        font-size: 14px;
        color: #c9d1d9;
      }
      .graph-stats {
        display: flex;
        gap: 16px;
        font-size: 12px;
      }
      .graph-stat {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .graph-stat-value {
        font-weight: bold;
        color: #58a6ff;
      }
      .graph-stat-label {
        color: #8b949e;
      }
      #graph-container {
        width: 100%;
        height: 400px;
        background: #0d1117;
      }
      #graph-svg {
        width: 100%;
        height: 100%;
      }
      .node circle {
        stroke-width: 2px;
        cursor: pointer;
        transition: stroke-width 0.2s;
      }
      .node:hover circle {
        stroke-width: 4px;
      }
      .node.running circle {
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }
      .node-label {
        font-size: 10px;
        fill: #8b949e;
        text-anchor: middle;
        pointer-events: none;
      }
      .link {
        stroke-opacity: 0.6;
        stroke-linecap: round;
      }
      .activity-feed {
        max-height: 200px;
        overflow-y: auto;
        border-top: 1px solid #30363d;
      }
      .activity-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 16px;
        background: #21262d;
        border-bottom: 1px solid #30363d;
        font-size: 12px;
        color: #8b949e;
      }
      .activity-item {
        padding: 8px 16px;
        border-bottom: 1px solid #21262d;
        font-size: 12px;
      }
      .activity-item:hover {
        background: #21262d;
      }
      .activity-item .node-name {
        color: #58a6ff;
        font-weight: 500;
      }
      .activity-item .role {
        display: inline-block;
        padding: 1px 6px;
        border-radius: 4px;
        font-size: 10px;
        margin-left: 4px;
      }
      .activity-item .role.system {
        background: #1f6feb33;
        color: #58a6ff;
      }
      .activity-item .role.agent {
        background: #23863633;
        color: #3fb950;
      }
      .activity-item .role.model {
        background: #a371f733;
        color: #a371f7;
      }
      .activity-item .role.error {
        background: #f8514933;
        color: #f85149;
      }
      .activity-item .content {
        color: #8b949e;
        margin-top: 4px;
        word-break: break-word;
      }
      .activity-item .timestamp {
        color: #484f58;
        font-size: 10px;
      }
      .node-details {
        padding: 16px;
        border-top: 1px solid #30363d;
        display: none;
      }
      .node-details.visible {
        display: block;
      }
      .node-details h4 {
        margin: 0 0 8px 0;
        color: #c9d1d9;
        font-size: 14px;
      }
      .node-details .detail-row {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        padding: 4px 0;
      }
      .node-details .detail-label {
        color: #8b949e;
      }
      .node-details .detail-value {
        color: #c9d1d9;
      }
      .graph-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 16px;
        border-top: 1px solid #30363d;
        font-size: 10px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .legend-color {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }
      .toggle-graph-btn {
        padding: 6px 12px;
        background: #21262d;
        border: 1px solid #30363d;
        border-radius: 4px;
        color: #8b949e;
        font-size: 12px;
        cursor: pointer;
      }
      .toggle-graph-btn:hover {
        background: #30363d;
        color: #c9d1d9;
      }
      .toggle-graph-btn.active {
        background: #1f6feb33;
        border-color: #1f6feb;
        color: #58a6ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîß SRE Incident Diagnosis <span class="version-badge" id="version-badge">v0.4.0</span></h1>
      <p class="subtitle">Autonomous infrastructure diagnosis with secure credential access</p>

      <div class="grid">
        <div class="card">
          <h2>New Diagnosis</h2>
          <form id="diagnose-form">
            <div class="form-group">
              <label for="problem">Problem Description</label>
              <textarea
                id="problem"
                placeholder="Describe the incident, e.g., 'Database connection timeouts in production API'"
              ></textarea>
            </div>
            <div class="form-group">
              <label for="environment">Environment</label>
              <select id="environment">
                <option value="prod">Production</option>
                <option value="staging">Staging</option>
                <option value="dev">Development</option>
              </select>
            </div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap">
              <button type="submit" class="btn btn-primary">Start Diagnosis</button>
              <button type="button" id="swarm-btn" class="btn btn-secondary" onclick="startSwarmDiagnosis()">
                üêù Swarm (150+ agents)
              </button>
            </div>
          </form>
        </div>

        <div class="card">
          <h2>Active Sessions</h2>
          <ul id="sessions-list" class="sessions-list">
            <li class="empty-state">No active sessions</li>
          </ul>
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px">
            <div style="display: flex; gap: 8px">
              <button id="refresh-btn" class="btn btn-secondary">Refresh</button>
              <button id="toggle-graph-btn" class="toggle-graph-btn" onclick="toggleGraphPanel()">üìä Graph</button>
            </div>
            <label class="auto-refresh-toggle">
              <input type="checkbox" id="auto-refresh-toggle" checked />
              Auto-refresh
            </label>
          </div>
        </div>
      </div>

      <div class="card" id="session-detail" style="display: none">
        <!-- Session Banner - Shows prominently at the top -->
        <div class="session-banner" id="session-banner">
          <div class="session-label">Session ID</div>
          <div class="session-id-large" id="banner-session-id"></div>
        </div>

        <h2>Session Details: <span id="detail-session-id"></span></h2>
        <div>
          <span class="status-badge" id="detail-status"></span>
          <span id="detail-phase" style="margin-left: 12px; color: #8b949e"></span>
          <span class="duration-badge" id="detail-duration" style="display: none"></span>
        </div>

        <!-- Streaming Output with Typewriter Effect -->
        <div class="streaming-output" id="streaming-output">
          <span id="streaming-text"></span><span class="cursor" id="streaming-cursor"></span>
        </div>

        <!-- Progress Bar -->
        <div id="progress-container" style="display: none">
          <div class="progress-bar-container">
            <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
          </div>
          <div class="progress-text" id="progress-text">Initializing...</div>
        </div>

        <!-- Two-Phase Progress Indicator -->
        <div class="phase-progress" id="phase-progress">
          <div class="phase-step" id="phase-analysis">
            <span class="icon">üìã</span>
            <span>Analysis</span>
          </div>
          <div class="phase-connector" id="connector-1"></div>
          <div class="phase-step" id="phase-approval">
            <span class="icon">üîê</span>
            <span>Approval</span>
          </div>
          <div class="phase-connector" id="connector-2"></div>
          <div class="phase-step" id="phase-credentials">
            <span class="icon">üîë</span>
            <span>Credentials</span>
          </div>
          <div class="phase-connector" id="connector-3"></div>
          <div class="phase-step" id="phase-diagnosis">
            <span class="icon">üîß</span>
            <span>Diagnosis</span>
          </div>
        </div>

        <p id="detail-problem" style="margin-top: 12px"></p>

        <div id="approval-section" class="approval-box" style="display: none">
          <h3>‚ö†Ô∏è Credential Access Required</h3>
          <p id="approval-message">The diagnosis agent needs access to the following credentials:</p>
          <ul id="credential-list"></ul>
          <div class="approval-actions">
            <button id="approve-btn" class="btn btn-primary">‚úì Approve Access</button>
            <button id="deny-btn" class="btn btn-danger">‚úó Deny</button>
          </div>
        </div>

        <div
          id="credentials-section"
          class="card"
          style="display: none; margin-top: 16px; background: #0a1628; border: 1px solid #1f6feb"
        >
          <h3>üîë Credentials Retrieved</h3>
          <p style="font-size: 13px; color: #8b949e; margin-bottom: 8px">
            The following credentials have been securely retrieved (values are stored internally, never exposed):
          </p>
          <ul id="credentials-list" style="margin: 0; padding-left: 20px; font-family: monospace; font-size: 12px"></ul>
        </div>

        <div id="analysis-section" class="card" style="display: none; margin-top: 16px; background: #0d1117">
          <h3>Analysis</h3>
          <div id="analysis-content" style="line-height: 1.6"></div>
        </div>

        <div id="findings-section" class="findings" style="display: none">
          <h3>Findings</h3>
          <div id="findings-list"></div>
        </div>

        <div class="log-output" id="log-output" style="margin-top: 16px">
          <div class="log-entry"><span class="log-time">[--:--:--]</span> Waiting for activity...</div>
        </div>
      </div>

      <!-- Agent Graph Visualization Panel -->
      <div class="graph-panel" id="graph-panel">
        <div class="graph-header">
          <h3>üîó Agent Graph</h3>
          <div class="graph-stats">
            <div class="graph-stat">
              <span class="graph-stat-value" id="stat-total">0</span>
              <span class="graph-stat-label">agents</span>
            </div>
            <div class="graph-stat">
              <span class="graph-stat-value" id="stat-running">0</span>
              <span class="graph-stat-label">running</span>
            </div>
            <div class="graph-stat">
              <span class="graph-stat-value" id="stat-completed">0</span>
              <span class="graph-stat-label">done</span>
            </div>
          </div>
        </div>
        <div id="graph-container">
          <svg id="graph-svg"></svg>
        </div>
        <div class="graph-legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #a78bfa"></div>
            Root
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #4ade80"></div>
            Diagnostic
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #ec4899"></div>
            Synthesis
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #06b6d4"></div>
            Runner
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #60a5fa"></div>
            Service
          </div>
        </div>
        <div class="node-details" id="node-details">
          <h4 id="node-details-name">Select a node</h4>
          <div class="detail-row">
            <span class="detail-label">Type:</span>
            <span class="detail-value" id="node-details-type">-</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Status:</span>
            <span class="detail-value" id="node-details-status">-</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Created:</span>
            <span class="detail-value" id="node-details-created">-</span>
          </div>
        </div>
        <div class="activity-header">
          <span>Activity Feed</span>
          <span id="activity-count">0 events</span>
        </div>
        <div class="activity-feed" id="activity-feed"></div>
      </div>
    </div>

    <script>
      const API_BASE = "";
      let currentSessionId = null;
      let pollInterval = null;
      let autoRefreshEnabled = true;
      let currentProgress = 0;

      // Typewriter state
      let typewriterQueue = [];
      let isTyping = false;
      let streamingBuffer = "";
      const TYPEWRITER_DELAY = 2; // ms per character

      // === Graph Visualization State ===
      let graphNodes = [];
      let graphEdges = [];
      let simulation = null;
      let selectedNode = null;
      let graphPollInterval = null;

      // Node type colors
      const typeColors = {
        root: "#a78bfa",
        region: "#22d3ee",
        service: "#60a5fa",
        runner: "#06b6d4",
        "diagnostic-agent": "#4ade80",
        "sub-agent": "#fbbf24",
        synthesis: "#ec4899",
      };

      // Status colors for node stroke
      const statusColors = {
        pending: "#666",
        running: "#facc15",
        completed: "#4ade80",
        error: "#f87171",
      };

      // Update progress bar
      function updateProgress(percent, text) {
        currentProgress = percent;
        const container = document.getElementById("progress-container");
        const bar = document.getElementById("progress-bar");
        const textEl = document.getElementById("progress-text");

        container.style.display = percent < 100 ? "block" : "none";
        bar.style.width = `${percent}%`;
        if (text) textEl.textContent = text;
      }

      // Format duration
      function formatDuration(seconds) {
        if (seconds < 60) return `${seconds.toFixed(1)}s`;
        const mins = Math.floor(seconds / 60);
        const secs = (seconds % 60).toFixed(0);
        return `${mins}m ${secs}s`;
      }

      // Format timestamp
      function formatTime(date) {
        return date.toTimeString().split(" ")[0];
      }

      // Add log entry
      function addLog(message, level = "info") {
        const logOutput = document.getElementById("log-output");
        const entry = document.createElement("div");
        entry.className = "log-entry";
        entry.innerHTML = `<span class="log-time">[${formatTime(new Date())}]</span> <span class="log-${level}">${message}</span>`;
        logOutput.appendChild(entry);
        logOutput.scrollTop = logOutput.scrollHeight;
      }

      // Clear logs
      function clearLogs() {
        document.getElementById("log-output").innerHTML = "";
      }

      // === Graph Visualization Functions ===

      let graphInitialized = false;

      function initGraph() {
        const container = document.getElementById("graph-container");
        const svg = d3.select("#graph-svg");

        // Use default dimensions if container not visible yet
        let width = container.clientWidth || 400;
        let height = container.clientHeight || 400;

        svg.attr("viewBox", [0, 0, width, height]);

        // Clear any existing content
        svg.selectAll("*").remove();

        // Create groups for links and nodes
        svg.append("g").attr("class", "links");
        svg.append("g").attr("class", "nodes");

        // Setup zoom
        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 4])
          .on("zoom", (event) => {
            svg.selectAll("g").attr("transform", event.transform);
          });
        svg.call(zoom);

        // Initialize force simulation with adjusted forces for large graphs
        simulation = d3
          .forceSimulation()
          .force(
            "link",
            d3
              .forceLink()
              .id((d) => d.id)
              .distance(50),
          )
          .force("charge", d3.forceManyBody().strength(-100))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(20))
          .on("tick", ticked);

        graphInitialized = true;
      }

      function reinitGraphIfNeeded() {
        const container = document.getElementById("graph-container");
        const svg = d3.select("#graph-svg");
        const width = container.clientWidth || 400;
        const height = container.clientHeight || 400;

        if (width > 0 && height > 0 && simulation) {
          svg.attr("viewBox", [0, 0, width, height]);
          simulation.force("center", d3.forceCenter(width / 2, height / 2));
          simulation.alpha(0.3).restart();
        }
      }

      function ticked() {
        const svg = d3.select("#graph-svg");

        svg
          .select(".links")
          .selectAll("line")
          .attr("x1", (d) => d.source.x)
          .attr("y1", (d) => d.source.y)
          .attr("x2", (d) => d.target.x)
          .attr("y2", (d) => d.target.y);

        svg
          .select(".nodes")
          .selectAll(".node")
          .attr("transform", (d) => `translate(${d.x}, ${d.y})`);
      }

      function getNodeRadius(d) {
        // Smaller radii for large graphs
        const nodeCount = graphNodes.length;
        const scale = nodeCount > 100 ? 0.6 : nodeCount > 50 ? 0.8 : 1;

        let baseRadius;
        switch (d.type) {
          case "root":
            baseRadius = 20;
            break;
          case "region":
            baseRadius = 15;
            break;
          case "runner":
            baseRadius = 12;
            break;
          case "service":
            baseRadius = 10;
            break;
          case "synthesis":
            baseRadius = 15;
            break;
          default:
            baseRadius = 6;
        }
        return baseRadius * scale;
      }

      function updateGraph(newNodes, newEdges) {
        const svg = d3.select("#graph-svg");
        const container = document.getElementById("graph-container");
        const width = container.clientWidth;
        const height = container.clientHeight;

        // Update nodes with positions
        const nodeMap = new Map(graphNodes.map((n) => [n.id, n]));
        newNodes.forEach((newNode) => {
          const existing = nodeMap.get(newNode.id);
          if (existing) {
            Object.assign(existing, newNode);
          } else {
            // New node - position near parent or center
            const parent = graphNodes.find((n) => n.id === newNode.parent);
            if (parent && parent.x !== undefined) {
              newNode.x = parent.x + (Math.random() - 0.5) * 50;
              newNode.y = parent.y + (Math.random() - 0.5) * 50;
            } else {
              newNode.x = width / 2 + (Math.random() - 0.5) * 100;
              newNode.y = height / 2 + (Math.random() - 0.5) * 100;
            }
            graphNodes.push(newNode);
          }
        });

        graphEdges = newEdges.map((e) => ({ source: e.source, target: e.target }));

        renderGraph();
      }

      function renderGraph() {
        const svg = d3.select("#graph-svg");

        // Update links
        const links = svg
          .select(".links")
          .selectAll("line")
          .data(graphEdges, (d) => `${d.source.id || d.source}-${d.target.id || d.target}`);

        links.exit().remove();

        links.enter().append("line").attr("class", "link").attr("stroke", "#4a5568").attr("stroke-width", 2);

        // Update nodes
        const nodes = svg
          .select(".nodes")
          .selectAll(".node")
          .data(graphNodes, (d) => d.id);

        nodes.exit().remove();

        const nodeEnter = nodes
          .enter()
          .append("g")
          .attr("class", (d) => `node ${d.status === "running" ? "running" : ""}`)
          .call(d3.drag().on("start", dragStarted).on("drag", dragged).on("end", dragEnded))
          .on("click", (event, d) => {
            event.stopPropagation();
            showNodeDetails(d);
          });

        nodeEnter
          .append("circle")
          .attr("r", (d) => getNodeRadius(d))
          .attr("fill", (d) => typeColors[d.type] || "#666")
          .attr("stroke", (d) => statusColors[d.status] || "#666")
          .attr("stroke-width", 2);

        nodeEnter
          .append("text")
          .attr("class", "node-label")
          .attr("dy", (d) => getNodeRadius(d) + 12)
          .text((d) => (d.name.length > 15 ? d.name.substring(0, 12) + "..." : d.name));

        // Update existing nodes
        const allNodes = nodes.merge(nodeEnter);

        allNodes.attr("class", (d) => `node ${d.status === "running" ? "running" : ""}`);

        allNodes
          .select("circle")
          .attr("fill", (d) => typeColors[d.type] || "#666")
          .attr("stroke", (d) => statusColors[d.status] || "#666");

        // Update simulation
        simulation.nodes(graphNodes);
        simulation.force("link").links(graphEdges);
        simulation.alpha(0.3).restart();

        // Update stats
        updateGraphStats();
      }

      function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      function updateGraphStats() {
        const total = graphNodes.length;
        const running = graphNodes.filter((n) => n.status === "running").length;
        const completed = graphNodes.filter((n) => n.status === "completed").length;

        document.getElementById("stat-total").textContent = total;
        document.getElementById("stat-running").textContent = running;
        document.getElementById("stat-completed").textContent = completed;
      }

      function showNodeDetails(node) {
        selectedNode = node;
        const details = document.getElementById("node-details");
        details.classList.add("visible");

        document.getElementById("node-details-name").textContent = node.name;
        document.getElementById("node-details-type").textContent = node.type;
        document.getElementById("node-details-status").textContent = node.status;
        document.getElementById("node-details-created").textContent = node.created_at
          ? new Date(node.created_at).toLocaleTimeString()
          : "-";
      }

      async function fetchGraphData() {
        try {
          const response = await fetch(`${API_BASE}/graph`);
          const data = await response.json();

          if (data.nodes && data.nodes.length > 0) {
            updateGraph(data.nodes, data.edges);
            // Show graph panel if we have nodes
            document.getElementById("graph-panel").classList.add("visible");
          }
        } catch (error) {
          console.error("Failed to fetch graph:", error);
        }
      }

      async function fetchActivityFeed() {
        try {
          const response = await fetch(`${API_BASE}/activity`);
          const activity = await response.json();

          const feed = document.getElementById("activity-feed");
          feed.innerHTML = "";

          activity.slice(0, 20).forEach((item) => {
            const div = document.createElement("div");
            div.className = "activity-item";
            div.innerHTML = `
              <span class="node-name">${escapeHtml(item.node_name)}</span>
              <span class="role ${item.role}">${item.role}</span>
              <span class="timestamp">${new Date(item.timestamp).toLocaleTimeString()}</span>
              <div class="content">${escapeHtml(item.content)}</div>
            `;
            feed.appendChild(div);
          });

          document.getElementById("activity-count").textContent = `${activity.length} events`;
        } catch (error) {
          console.error("Failed to fetch activity:", error);
        }
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function startGraphPolling() {
        if (graphPollInterval) clearInterval(graphPollInterval);
        // Reinitialize graph when starting polling (panel just became visible)
        setTimeout(reinitGraphIfNeeded, 100);
        graphPollInterval = setInterval(() => {
          fetchGraphData();
          fetchActivityFeed();
        }, 1000);
      }

      function stopGraphPolling() {
        if (graphPollInterval) {
          clearInterval(graphPollInterval);
          graphPollInterval = null;
        }
      }

      function toggleGraphPanel() {
        const panel = document.getElementById("graph-panel");
        panel.classList.toggle("visible");
        // Reinitialize graph when panel becomes visible
        if (panel.classList.contains("visible")) {
          setTimeout(reinitGraphIfNeeded, 100);
        }
      }

      // Fetch sessions
      async function fetchSessions() {
        try {
          const response = await fetch(`${API_BASE}/sessions`);
          const data = await response.json();
          renderSessions(data.sessions);
        } catch (error) {
          console.error("Failed to fetch sessions:", error);
        }
      }

      // Render sessions list
      function renderSessions(sessions) {
        const list = document.getElementById("sessions-list");
        if (sessions.length === 0) {
          list.innerHTML = '<li class="empty-state">No active sessions</li>';
          return;
        }
        list.innerHTML = sessions
          .map(
            (s) => `
                <li class="session-item" onclick="selectSession('${s.session_id}')">
                    <div class="session-info">
                        <div class="session-id">${s.session_id}${s.credentials_retrieved > 0 ? " üîë" + s.credentials_retrieved : ""}</div>
                        <div class="session-problem">${s.problem}</div>
                    </div>
                    <span class="status-badge status-${s.status}">${s.status}</span>
                </li>
            `,
          )
          .join("");
      }

      // Select session
      async function selectSession(sessionId) {
        currentSessionId = sessionId;
        document.getElementById("session-detail").style.display = "block";
        document.getElementById("detail-session-id").textContent = sessionId;
        clearLogs();
        addLog(`Selected session ${sessionId}`, "info");
        await updateSessionDetail();
        startPolling();

        // Start graph polling and show graph panel
        startGraphPolling();
        document.getElementById("graph-panel").classList.add("visible");
      }

      // Update phase progress indicator
      function updatePhaseProgress(phase, status) {
        const phases = ["analysis", "approval", "credentials", "diagnosis"];
        const phaseMap = {
          analyzing: 0,
          analysis: 0,
          awaiting_approval: 1,
          waiting_for_approval: 1,
          credential_retrieval: 2,
          retrieving_credentials: 2,
          diagnosis: 3,
          diagnosing: 3,
          diagnosis_complete: 4,
          completed: 4,
          error: -1,
          denied: -1,
          credentials_denied: -1,
        };

        const currentPhase = phaseMap[phase] ?? phaseMap[status] ?? 0;

        phases.forEach((p, i) => {
          const stepEl = document.getElementById(`phase-${p}`);
          const connectorEl = document.getElementById(`connector-${i + 1}`);

          if (i < currentPhase) {
            stepEl.className = "phase-step completed";
            if (connectorEl) connectorEl.className = "phase-connector completed";
          } else if (i === currentPhase && currentPhase < 4) {
            stepEl.className = "phase-step active";
            if (connectorEl) connectorEl.className = "phase-connector";
          } else {
            stepEl.className = "phase-step";
            if (connectorEl) connectorEl.className = "phase-connector";
          }
        });

        // Special handling for completed state
        if (status === "completed" || phase === "diagnosis_complete") {
          phases.forEach((p, i) => {
            document.getElementById(`phase-${p}`).className = "phase-step completed";
            const conn = document.getElementById(`connector-${i + 1}`);
            if (conn) conn.className = "phase-connector completed";
          });
        }
      }

      // Update session detail
      async function updateSessionDetail() {
        if (!currentSessionId) return;

        try {
          const response = await fetch(`${API_BASE}/status/${currentSessionId}`);
          const data = await response.json();

          document.getElementById("detail-status").textContent = data.status;
          document.getElementById("detail-status").className = `status-badge status-${data.status}`;
          document.getElementById("detail-phase").textContent = `Phase: ${data.phase}`;

          // Update phase progress indicator
          updatePhaseProgress(data.phase, data.status);

          // Show approval section if waiting
          const approvalSection = document.getElementById("approval-section");
          if (data.phase === "awaiting_approval" || data.status === "waiting_for_approval") {
            approvalSection.style.display = "block";
            if (data.approval_prompt) {
              document.getElementById("approval-message").textContent = data.approval_prompt;
            }
          } else {
            approvalSection.style.display = "none";
          }

          // Show credentials retrieved section
          const credsSection = document.getElementById("credentials-section");
          if (credsSection && data.credentials_retrieved && data.credentials_retrieved.length > 0) {
            credsSection.style.display = "block";
            document.getElementById("credentials-list").innerHTML = data.credentials_retrieved
              .map((ref) => `<li><code>${ref}</code></li>`)
              .join("");
          } else if (credsSection) {
            credsSection.style.display = "none";
          }

          // Show analysis if available
          if (data.analysis) {
            const analysisSection = document.getElementById("analysis-section");
            if (analysisSection) {
              analysisSection.style.display = "block";
              document.getElementById("analysis-content").innerHTML = formatMarkdown(data.analysis);
            }
          }

          // Show findings if available
          if (data.findings && data.findings.length > 0) {
            document.getElementById("findings-section").style.display = "block";
            document.getElementById("findings-list").innerHTML = data.findings
              .map(
                (f) => `
                        <div class="finding finding-${f.severity || "info"}">
                            <strong>${f.title || "Finding"}</strong>
                            <p>${f.description || f}</p>
                        </div>
                    `,
              )
              .join("");
          }
        } catch (error) {
          addLog(`Error fetching status: ${error.message}`, "error");
        }
      }

      // Start polling for updates
      function startPolling() {
        if (pollInterval) clearInterval(pollInterval);
        if (autoRefreshEnabled) {
          pollInterval = setInterval(() => {
            updateSessionDetail();
            fetchSessions();
          }, 2000);
        }
      }

      // Stop polling
      function stopPolling() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
      }

      // Simple markdown formatter
      function formatMarkdown(text) {
        if (!text) return "";
        return text
          .replace(/^## (.+)$/gm, "<h3>$1</h3>")
          .replace(/^### (.+)$/gm, "<h4>$1</h4>")
          .replace(/^\- (.+)$/gm, "<li>$1</li>")
          .replace(/^\d+\. (.+)$/gm, "<li>$1</li>")
          .replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>")
          .replace(/\n/g, "<br>");
      }

      // Show session banner
      function showSessionBanner(sessionId) {
        const banner = document.getElementById("session-banner");
        const bannerSessionId = document.getElementById("banner-session-id");
        banner.style.display = "block";
        bannerSessionId.textContent = sessionId;
      }

      // Initialize streaming output
      function initStreamingOutput() {
        const output = document.getElementById("streaming-output");
        const textEl = document.getElementById("streaming-text");
        const cursor = document.getElementById("streaming-cursor");
        output.style.display = "block";
        textEl.innerHTML = "";
        streamingBuffer = "";
        typewriterQueue = [];
        cursor.style.display = "inline-block";
      }

      // Hide streaming cursor
      function hideStreamingCursor() {
        document.getElementById("streaming-cursor").style.display = "none";
      }

      // Add text to typewriter queue and process
      function queueTypewriterText(text) {
        // Buffer the text fragments
        streamingBuffer += text;

        // Check for complete sentences or significant chunks
        // Split on sentence endings, newlines, or after accumulating enough text
        const sentenceEndings = /([.!?]\s+|\n\n|\n(?=[A-Z#*\-\d]))/g;
        let match;
        let lastIndex = 0;

        while ((match = sentenceEndings.exec(streamingBuffer)) !== null) {
          const sentence = streamingBuffer.substring(lastIndex, match.index + match[0].length);
          if (sentence.trim()) {
            typewriterQueue.push(sentence);
          }
          lastIndex = match.index + match[0].length;
        }

        // Keep the incomplete part in the buffer
        streamingBuffer = streamingBuffer.substring(lastIndex);

        // If buffer is getting long without sentence breaks, flush it
        if (streamingBuffer.length > 100) {
          typewriterQueue.push(streamingBuffer);
          streamingBuffer = "";
        }

        // Start processing queue if not already typing
        if (!isTyping) {
          processTypewriterQueue();
        }
      }

      // Flush remaining buffer
      function flushTypewriterBuffer() {
        if (streamingBuffer.trim()) {
          typewriterQueue.push(streamingBuffer);
          streamingBuffer = "";
        }
        if (!isTyping && typewriterQueue.length > 0) {
          processTypewriterQueue();
        }
      }

      // Process typewriter queue with character-by-character effect
      async function processTypewriterQueue() {
        if (isTyping || typewriterQueue.length === 0) return;

        isTyping = true;
        const textEl = document.getElementById("streaming-text");
        const output = document.getElementById("streaming-output");

        while (typewriterQueue.length > 0) {
          const text = typewriterQueue.shift();

          for (const char of text) {
            // Handle special characters for formatting
            if (char === "\n") {
              textEl.innerHTML += "<br>";
            } else if (char === "#" && textEl.innerHTML.endsWith("<br>")) {
              textEl.innerHTML += '<span style="color: #58a6ff; font-weight: bold;">#</span>';
            } else if (char === "*") {
              textEl.innerHTML += '<span style="color: #d29922;">*</span>';
            } else {
              textEl.innerHTML += char.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }

            // Scroll to bottom
            output.scrollTop = output.scrollHeight;

            // Variable delay - faster for spaces, slower for punctuation
            let delay = TYPEWRITER_DELAY;
            if (char === " ") delay = TYPEWRITER_DELAY / 2;
            else if (".!?".includes(char)) delay = TYPEWRITER_DELAY * 3;
            else if (",;:".includes(char)) delay = TYPEWRITER_DELAY * 2;

            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }

        isTyping = false;
      }

      // Stream NDJSON response
      async function streamResponse(response, onChunk) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";

          for (const line of lines) {
            if (line.trim()) {
              try {
                const data = JSON.parse(line);
                onChunk(data);
              } catch (e) {
                console.warn("Failed to parse line:", line);
              }
            }
          }
        }
      }

      // Submit diagnosis form
      document.getElementById("diagnose-form").addEventListener("submit", async (e) => {
        e.preventDefault();
        const problem = document.getElementById("problem").value;
        const environment = document.getElementById("environment").value;

        if (!problem.trim()) {
          alert("Please describe the problem");
          return;
        }

        try {
          addLog("Starting diagnosis...", "info");
          const response = await fetch(`${API_BASE}/diagnose`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ problem, environment }),
          });

          // Stream the response
          await streamResponse(response, (data) => {
            if (data.type === "session_start") {
              currentSessionId = data.session_id;
              document.getElementById("session-detail").style.display = "block";
              document.getElementById("detail-session-id").textContent = data.session_id;

              // Show session banner prominently
              showSessionBanner(data.session_id);
              initStreamingOutput();

              // Start graph polling and show graph panel
              startGraphPolling();
              document.getElementById("graph-panel").classList.add("visible");

              addLog(`üöÄ Session ${data.session_id} started - Phase 1: Analysis`, "info");
              updatePhaseProgress("analysis", "analyzing");
              updateProgress(data.progress || 0, "Analyzing problem...");
              fetchSessions();
            } else if (data.type === "approval_required") {
              flushTypewriterBuffer();
              hideStreamingCursor();
              addLog(`üîê Analysis complete - ${data.requested_credentials?.length || 0} credentials requested`, "warn");
              document.getElementById("approval-section").style.display = "block";
              document.getElementById("approval-message").textContent =
                `The agent needs access to ${data.requested_credentials?.length || 0} credentials to complete diagnosis:`;
              updatePhaseProgress("awaiting_approval", "waiting_for_approval");
              updateProgress(data.progress || 100, "Waiting for approval...");
              updateSessionDetail();
              fetchSessions();
            } else if (data.type === "session_complete") {
              flushTypewriterBuffer();
              hideStreamingCursor();
              addLog("‚úÖ Analysis complete", "info");
              updateSessionDetail();
              fetchSessions();
            } else if (data.type === "error") {
              addLog(`‚ùå Error: ${data.message}`, "error");
            } else if (data.text) {
              // Stream text with typewriter effect (skip timestamps)
              if (!data.text.match(/^\d{4}-\d{2}-\d{2}/)) {
                queueTypewriterText(data.text);
              }
            }
          });

          document.getElementById("problem").value = "";
        } catch (error) {
          addLog(`Failed to start diagnosis: ${error.message}`, "error");
        }
      });

      // Approve credentials
      document.getElementById("approve-btn").addEventListener("click", async () => {
        if (!currentSessionId) return;
        try {
          addLog("Sending approval...", "info");
          document.getElementById("approval-section").style.display = "none";

          const response = await fetch(`${API_BASE}/approve/${currentSessionId}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ approved: true, message: "approve" }),
          });

          // Stream the resumed agent response
          let credentialCount = 0;
          let specialistCount = 0;

          // Re-initialize streaming output for diagnosis phase
          initStreamingOutput();

          await streamResponse(response, (data) => {
            if (data.type === "approval_accepted") {
              addLog("‚úÖ Credentials approved - Phase 2: Retrieving credentials...", "info");
              updatePhaseProgress("credential_retrieval", "retrieving_credentials");
              updateProgress(data.progress || 0, "Retrieving credentials...");
            } else if (data.type === "credential_retrieved") {
              credentialCount++;
              const icon = data.success ? "üîë" : "‚ùå";
              const status = data.success ? "retrieved" : "failed";
              addLog(
                `${icon} Credential ${credentialCount}: ${data.reference} - ${status}`,
                data.success ? "info" : "error",
              );
            } else if (data.type === "diagnosis_started") {
              const failedNote = data.credentials_failed > 0 ? ` (${data.credentials_failed} failed)` : "";
              addLog(`üîß Starting diagnosis with ${data.credentials_retrieved} credentials${failedNote}...`, "info");
              updatePhaseProgress("diagnosis", "diagnosing");
              updateProgress(data.progress || 20, "Starting specialist agents...");
            } else if (data.type === "specialists_selected") {
              const specialists = data.specialists || [];
              addLog(`ü§ñ Running ${specialists.length} specialist agents: ${specialists.join(", ")}`, "info");
              updateProgress(data.progress || 25, `Running ${specialists.length} specialists in parallel...`);
            } else if (data.type === "specialist_complete") {
              specialistCount++;
              const agentName = data.agent?.replace("_specialist", "") || "unknown";
              const icon = data.status === "completed" ? "‚úÖ" : "‚ö†Ô∏è";
              const durationInfo = data.duration_seconds ? ` (${data.duration_seconds}s)` : "";
              addLog(`${icon} Specialist #${specialistCount} (${agentName}): ${data.status}${durationInfo}`, "info");
              updateProgress(data.progress || 50, `Specialist ${specialistCount} complete...`);
            } else if (data.type === "specialist_error") {
              addLog(`‚ùå Specialist error: ${data.error}`, "error");
            } else if (data.type === "synthesis_started") {
              addLog(`üß™ Synthesizing findings from ${data.findings_count || "all"} specialists...`, "info");
              updateProgress(data.progress || 60, "Synthesizing findings...");
            } else if (data.type === "diagnosis_complete") {
              flushTypewriterBuffer();
              hideStreamingCursor();
              const durationInfo = data.duration_seconds ? ` in ${formatDuration(data.duration_seconds)}` : "";
              addLog(`‚úÖ Diagnosis complete${durationInfo}!`, "info");
              updatePhaseProgress("diagnosis_complete", "completed");
              updateProgress(100, "Complete!");

              // Show duration badge
              if (data.duration_seconds) {
                const durationBadge = document.getElementById("detail-duration");
                durationBadge.textContent = `Duration: ${formatDuration(data.duration_seconds)}`;
                durationBadge.style.display = "inline-block";
              }

              // Final graph update then stop polling
              fetchGraphData();
              fetchActivityFeed();
              setTimeout(() => stopGraphPolling(), 2000);

              updateSessionDetail();
              fetchSessions();
            } else if (data.type === "error") {
              addLog(`‚ùå Error: ${data.message}`, "error");
            } else if (data.text) {
              // Stream text with typewriter effect (skip timestamps)
              if (!data.text.match(/^\d{4}-\d{2}-\d{2}/)) {
                queueTypewriterText(data.text);
              }
            }
          });

          await updateSessionDetail();
          await fetchSessions();
        } catch (error) {
          addLog(`Approval failed: ${error.message}`, "error");
        }
      });

      // Deny credentials
      document.getElementById("deny-btn").addEventListener("click", async () => {
        if (!currentSessionId) return;
        try {
          await fetch(`${API_BASE}/approve/${currentSessionId}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ approved: false }),
          });
          addLog("Credentials denied", "warn");
          await updateSessionDetail();
          await fetchSessions();
        } catch (error) {
          addLog(`Denial failed: ${error.message}`, "error");
        }
      });

      // Refresh button
      document.getElementById("refresh-btn").addEventListener("click", fetchSessions);

      // Auto-refresh toggle
      document.getElementById("auto-refresh-toggle").addEventListener("change", (e) => {
        autoRefreshEnabled = e.target.checked;
        if (autoRefreshEnabled && currentSessionId) {
          startPolling();
        } else {
          stopPolling();
        }
        addLog(autoRefreshEnabled ? "Auto-refresh enabled" : "Auto-refresh disabled", "info");
      });

      // Initialize graph on page load
      document.addEventListener("DOMContentLoaded", () => {
        initGraph();
        // Also reinit when window resizes
        window.addEventListener("resize", () => {
          const panel = document.getElementById("graph-panel");
          if (panel.classList.contains("visible")) {
            reinitGraphIfNeeded();
          }
        });
      });

      // Fetch version from health endpoint
      async function fetchVersion() {
        try {
          const response = await fetch(`${API_BASE}/health`);
          const data = await response.json();
          if (data.version) {
            document.getElementById("version-badge").textContent = `v${data.version}`;
          }
        } catch (e) {
          console.warn("Failed to fetch version");
        }
      }

      // Start swarm diagnosis (150+ agents)
      async function startSwarmDiagnosis() {
        const problem =
          document.getElementById("problem").value || "Production API experiencing latency spikes across all regions";
        const environment = document.getElementById("environment").value;

        try {
          addLog("üêù Starting swarm diagnosis with 150+ agents...", "info");
          const response = await fetch(`${API_BASE}/diagnose/swarm`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ problem, environment }),
          });

          // Stream the response
          await streamResponse(response, (data) => {
            if (data.type === "swarm_started") {
              currentSessionId = data.session_id;
              document.getElementById("session-detail").style.display = "block";
              document.getElementById("detail-session-id").textContent = data.session_id;

              // Show session banner
              showSessionBanner(data.session_id);
              initStreamingOutput();

              // Start graph polling and show graph panel
              startGraphPolling();
              document.getElementById("graph-panel").classList.add("visible");

              addLog(`üêù Swarm started: ${data.total_agents} agents across ${data.total_targets} targets`, "info");
              updatePhaseProgress("diagnosis", "diagnosing");
              updateProgress(data.progress || 0, `Spawning ${data.total_agents} agents...`);
              fetchSessions();

              // Hide approval section for swarm (no credentials needed)
              document.getElementById("approval-section").style.display = "none";
            } else if (data.type === "swarm_collection_complete") {
              addLog(`üìä Collected results from ${data.results_count} services`, "info");
              updateProgress(data.progress || 70, "Synthesizing findings...");
            } else if (data.type === "synthesis_started") {
              addLog(`üß† Synthesis agent combining ${data.findings_count} findings`, "info");
              updateProgress(data.progress || 75, "Synthesizing...");
            } else if (data.type === "swarm_complete") {
              flushTypewriterBuffer();
              hideStreamingCursor();
              addLog(`‚úÖ Swarm complete: ${data.total_agents} agents in ${data.duration_seconds}s`, "info");
              updatePhaseProgress("diagnosis_complete", "completed");
              updateProgress(100, "Complete");
              fetchSessions();
            } else if (data.type === "error") {
              addLog(`‚ùå Error: ${data.message}`, "error");
            } else if (data.text) {
              // Stream synthesis text with typewriter effect
              if (!data.text.match(/^\d{4}-\d{2}-\d{2}/)) {
                queueTypewriterText(data.text);
              }
            }
          });
        } catch (error) {
          addLog(`Swarm diagnosis failed: ${error.message}`, "error");
        }
      }

      // Initial load
      fetchSessions();
      fetchVersion();
    </script>
  </body>
</html>
