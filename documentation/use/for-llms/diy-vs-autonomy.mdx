---
title: "DIY vs Autonomy"
description: "A comparison of Autonomy vs. rolling your own autonomous platform using cloud-native technologies."
mode: "wide"
---

<div id="force-wide-mode" />

| Feature                                       | Cloud-Native (DIY)                                                     | Autonomy                                                 | Completeness | DIY Pain                                                                                                                                                                                                                                                                             | Autonomy Advantage                                                                                                                                                                                                                                                                                                             |
| :-------------------------------------------- | :--------------------------------------------------------------------- | :------------------------------------------------------- | :----------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **EXECUTION AND RUNTIME**                     |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Unit at run time**                          | Container / Pod / Lambda                                               | Actor                                                    | Completed    | Heavy (MBs-GBs), slow startup, requires orchestration, image registries, deployment pipelines.                                                                                                                                                                                       | Actors: ~1M per server. Lightweight stateful objects with unique address, mailbox, private state. Idle actors consume no CPU. Runtime automatically gives CPU to actors with messages.                                                                                                                                         |
| **Life span of a task**                       | Milliseconds                                                           | Seconds to Days                                          | Completed    | HTTP Req → DB → Resp. Long-running requires Step Functions, chains of Lambdas, custom checkpoint/resume, etc. Complexity explodes with state management.                                                                                                                             | Agents loop: build context → decide → call tools → gather responses. Loop runs for thousands of iterations until goal achieved.                                                                                                                                                                                                |
| **Where state lives**                         | External database                                                      | Actor's private internal state                           | Completed    | Build connection pooling, caching, consistency logic. State reconstruction on every invocation for serverless. Long-running agents require complex external state management.                                                                                                        | Each actor's state is completely private. Other actors cannot directly access or modify it. Eliminates race conditions and deadlocks. Long-running agents are simple. State just lives in the actor.                                                                                                                           |
| **Concurrency model**                         | One container or Lambda per user per agent                             | Actor                                                    | Completed    | For long-running agents, each concurrent user needs their own container or Lambda. Infrastructure units scale linearly with users. You have to manage and coordinate thousands of containers.                                                                                        | Each actor processes one message at a time. Messages queue in mailbox. No locks. Thousands of concurrent users share one container. Naturally concurrent without coordination overhead and infrastructure overhead.                                                                                                            |
| **Failure isolation**                         | Pod / Lambda level                                                     | Actor level                                              | Completed    | Crash takes down container and all work inside. Configure resource limits, disruption policies, security contexts, restart policies.                                                                                                                                                 | One actor crashes, others continue unaffected. No corruption propagation. Actors supervise other actors. Agents supervise sub-agents.                                                                                                                                                                                          |
| **Scaling**                                   | Dynamic infrastructure provisioning                                    | Agent spawning                                           | Completed    | Long-lived work per user means dynamically provisioning containers or Lambdas as users arrive. Orchestrate infrastructure at runtime, manage state in external DBs, handle cold starts under load.                                                                                   | Agents spawn sub-agents as needed. Thousands of actors share one container. No infrastructure provisioning per user. Scaling is just spawning more actors.                                                                                                                                                                     |
| **Cold starts**                               | 500ms - 2 minutes                                                      | 1-2 ms                                                   | Completed    | Optimize with pre-provisioned capacity, smaller images, init optimization, etc. Extremely challenging.                                                                                                                                                                               | Actors, and hence agents, start in milliseconds. Hundreds of thousands run in parallel inside a single process. No warming strategies, no image pulls, no scheduling delays.                                                                                                                                                   |
| **COMMUNICATION AND REACH**                   |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Communication**                             | HTTP, gRPC, Kafka, SQS                                                 | Actor messages over Ockam                                | Completed    | Build serialization, retries, circuit breakers, service discovery, schema versioning, dead letter queues, consumer groups. Scaling communication infrastructure adds another layer of complexity.                                                                                    | Asynchronous, non-blocking messages. All communication transparently mutually authenticated, end-to-end encrypted. High-throughput channels scale to max AWS network throughput.                                                                                                                                               |
| **Routing**                                   | Service mesh, DNS, LBs                                                 | Ockam Routing                                            | Completed    | Configure Istio/Linkerd, routing rules, topic partitions, consumer groups, service discovery, load balancer health checks.                                                                                                                                                           | Location transparency via application-layer routing.                                                                                                                                                                                                                                                                           |
| **Network reach**                             | VPN, PrivateLink, peering                                              | Ockam Relays + Portals                                   | Completed    | Months of networking work. Per-cloud configuration. Fragile connectivity. IP address management. Route table complexity.                                                                                                                                                             | Works across clouds, VPCs, across companies, into private data centers, to dev machines, through NAT using multi-hop, multi-transport routes. No network changes required.                                                                                                                                                     |
| **Private infrastructure**                    | Bastion, VPN, PrivateLink                                              | Ockam Portals                                            | Completed    | Manage jump hosts, configure VPN clients, set up AWS/Azure/GCP PrivateLink separately, audit access, distribute keys, maintain brittle IP allow lists.                                                                                                                               | Create a relay for the private resource. `autonomy zone outlet` creates an encrypted tunnel. The private resource appears virtually adjacent on localhost. Just works. No firewall changes.                                                                                                                                    |
| **Firewall traversal**                        | Reverse proxy, VPN                                                     | Outbound-only connections                                | Completed    | Manage firewall rules, audit changes, handle corporate security policies, maintain VPN infrastructure, deal with NAT complexity.                                                                                                                                                     | Ockam Relays use outbound-only connections. No inbound ports needed. No risky public endpoints. Works through corporate firewalls without IT involvement.                                                                                                                                                                      |
| **Backpressure**                              | Rate limiters, circuit breakers                                        | Mailbox semantics                                        | Completed    | Build and tune per-service. Implement circuit breakers, bulkheads, retry budgets. Different patterns for each queue/service.                                                                                                                                                         | Messages queue in actor mailboxes. Flow control is baked into secure channels. Backpressure is baked into the design.                                                                                                                                                                                                          |
| **Topology**                                  | Rigid, deploy-time                                                     | Dynamic, runtime                                         | Completed    | Topology changes require config updates and redeployment. Service mesh reconfiguration. DNS propagation delays.                                                                                                                                                                      | Agents create sub-agents at runtime. Topology emerges from execution. Parent spawns children as needed for the task at hand.                                                                                                                                                                                                   |
| **CONTEXT AND KNOWLEDGE**                     |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Short-term memory of conversation history** | Write code to manage conversation history                              | Automatic conversation history management and compaction | Completed    | Engineers have to write code to manage conversation history, handle sliding windows, and deal with stale data that can cause the agent to drift. It's a constant effort to keep the history of messages included in context relevant and avoid failures due to outdated information. | Conversation history management is automated by default. Engineers can tune by injecting their own context templates or setting parameters for summarization, trimming, and more.                                                                                                                                              |
| **Long-term storage of conversation history** | Store history in an external database (e.g., Redis, DynamoDB).         | Built-in, two-tier agent memory with persistence.        | Completed    | Requires provisioning and managing a separate database. Engineers must write boilerplate code for serialization, connection pooling, failover, and ensuring data consistency across every conversation.                                                                              | A built-in two-tier system provides in-memory speed with optional persistence. All messages, tool calls, and results are automatically stored durably with no extra code, ensuring no data is lost.                                                                                                                            |
| **Filesystem per agent**                      | Run one container per agent to provide a private filesystem.           | Virtual, isolated filesystem for every agent.            | Completed    | To give an agent a private filesystem, you generally have to dedicate a full container to it. This ties your agent density to your container density, making it expensive and inefficient to run thousands of agents.                                                                | Agents are significantly more successful at complex tasks when they have a filesystem to read, write, and manipulate files. Autonomy provides a virtual filesystem abstraction that is lightweight and isolated. Thousands of agents can share a single container while each maintains its own private, persistent file space. |
| **Long-term knowledge**                       | Set up and manage a vector store (e.g., pgvector, Pinecone, Weaviate). | Knowledge class                                          | Completed    | Deploy embedding service, provision vector DB, implement chunking strategies, build retrieval API, tune similarity thresholds, add reranking.                                                                                                                                        | Vector storage is automatically provisioned and managed. Simply define `Knowledge(name="docs", searchable=True, ...)` and the infrastructure is handled for you. Add docs with `add_text()` or `add_document(url)`, and `KnowledgeTool` enables agentic RAG.                                                                   |
| **Memory isolation**                          | Row-level security, schemas                                            | Scope + conversation                                     | Completed    | **Hand-roll tenant isolation** across every layer (DB, Vector Store, S3, Logs). One missed check in your application logic leads to a data leak between tenants. Constant auditing is required.                                                                                      | **Isolation is built-in, not tacked on.** Just pass `scope="tenant-123"` and `conversation="chat-456"`. Autonomy automatically partitions all state, memory, context, filesystem, and knowledge ensuring strict boundaries between tenants.                                                                                    |
| **RAG pipeline**                              | 5+ services to deploy                                                  | Integrated into `Knowledge` class                        | Completed    | Building a RAG pipeline requires stitching together an embedding service, vector DB, chunking logic, retrieval API, and reranking model. You have to manage the infrastructure and latency for each hop.                                                                             | RAG is a single class, not a complex system. Configure chunking, distance thresholds, and results with simple parameters like `NaiveChunker(...)` or `max_distance=0.2`. Easily ingest docs by calling `add_document`.                                                                                                         |
| **Parallel context gathering**                | Build custom fan-out infrastructure                                    | Native Agentic Scatter-Gather                            | Completed    | Collecting context from multiple sources in parallel requires building custom orchestration logic: task splitting, barrier synchronization, timeout handling, and result aggregation. Doing this reliably at scale is a **complex distributed systems project.**                     | **Designed to be embarrassingly parallel.** Autonomy brings **Spark-style fan-out** to agent execution. The actor runtime and automatic clustering allow agents to spawn thousands of sub-agents to gather context from disparate systems simultaneously. This speed makes unviable use cases viable.                          |
| **Just-in-time retrieval**                    | No native filesystem for agents                                        | References + Filesystem tools                            | Completed    | Because there is no persistent filesystem infrastructure, there is no place to save information to retrieve later. You are forced to stuff full content into the context window, which bloats costs and degrades reasoning performance.                                              | Built-in filesystem and fetch tools allow agents to store large content to disk and keep only references (paths/URLs) in context. The agent retrieves exactly what it needs, when it needs it, keeping the context window light and fast.                                                                                      |
| **DECISIONS AND REASONING**                   |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Access to models from multiple providers**  | Build or operate a custom model gateway                                | Model Gateway                                            | Completed    | You have to build unified interfaces to handle each provider's API quirks, manage credentials separately, normalize response formats, and implement your own fallback logic.                                                                                                         | Just use `Model("claude-sonnet-4")` or `Model("gpt-4o")`. The gateway handles routing, load balancing, and failover automatically. Change one string to switch providers.                                                                                                                                                      |
| **Select models**                             | Research, build routing                                                | Curated catalog                                          | Completed    | Research model capabilities, maintain compatibility matrices, handle deprecations, update integrations.                                                                                                                                                                              | `claude-sonnet-4-5` for most apps, `claude-opus-4-5` for complex reasoning, `nova-micro` for high volume, `embed-english-v3` for search. Transparent pricing.                                                                                                                                                                  |
| **Rate limiting**                             | Token buckets per provider                                             | Automatic throttling, queuing, and failover              | Completed    | Track usage per provider, enforce quotas, handle 429s manually, implement exponential backoff, and manage burst capacity logic in your application code.                                                                                                                             | The gateway automatically queues requests when rate limits are hit and can **automatically failover to an alternate provider**. Just set `throttle=True` and the system handles the backoff and retries.                                                                                                                       |
| **Streaming**                                 | WebSockets / SSE infrastructure                                        | Native `stream=true`                                     | Completed    | Maintaining long-lived WebSocket connections at scale requires specialized load balancers, stateful infrastructure, and complex client-side code to handle disconnects, backpressure, and reassembly.                                                                                | Streaming is a first-class citizen. Just add `?stream=true` to any agent endpoint. The system handles the connection management, backpressure, and framing automatically.                                                                                                                                                      |
| **Delegate tasks**                            | Manage queues, RPCs, correlate responses                               | `agent.send` / `delegate_to_subagent`                    | Completed    | Requires deploying and managing messaging infrastructure (Kafka/SQS) and RPC frameworks. You must handle correlation IDs, timeouts, and retries at the infrastructure level to delegate tasks.                                                                                       | **Just call a function.** Use `delegate_to_subagent(...)` for tool-based delegation or `agent.send(...)` for direct messaging. The system handles routing, execution, and return values automatically. No messaging infrastructure to provision or manage.                                                                     |
| **Agent Hierarchies**                         | Orchestrate state machines & workflows                                 | Native sub-agents                                        | Completed    | Modeling a hierarchy where a parent delegates to children requires complex distributed coordination: managing parent-child communication, tracking lineage, handling partial failures, and rolling back state. It quickly becomes a tangled distributed system.                      | **Hierarchies are native primitives.** Define children in config: `subagents={"researcher": ...}`. The parent automatically gets tools to start, stop, and delegate to children (`delegate_to_subagent`), with all coordination handled by the runtime.                                                                        |
| **Focused sub-agent context**                 | Build custom sub-agent abstraction                                     | Automatic context isolation                              | Completed    | To give sub-agents focused context, you have to build the entire sub-agent abstraction yourself, manage the context splitting, and coordinate the delegation.                                                                                                                        | **Sub-agents are Actors.** They inherently possess their own isolated state and context. When a parent delegates a task, the sub-agent starts with a focused context. Less noise means higher accuracy.                                                                                                                        |
| **Compose workflows**                         | Step Functions / Temporal                                              | Python code                                              | Completed    | Requires learning a proprietary DSL, deploying complex workflow infrastructure, and managing state serialization between steps. Debugging distributed workflows across these systems is painful.                                                                                     | **Just write Python.** Define flows as graphs of agents with standard conditions and operations. There is no separate workflow engine to deploy or manage.                                                                                                                                                                     |
| **Control costs**                             | Manually tune infrastructure and model costs                           | High Density + Zero-Cost Waiting                         | Completed    | You pay for containers and Lambdas even when they are just waiting for an LLM response or a user input. You must constantly tune instance types, manage reserved capacity, and handle spot interruptions to keep costs down.                                                         | **1M agents per container vs 1 agent per container.** Agents are actors that consume zero CPU when waiting, so you never pay for idle time. You also save by routing simple tasks to cheaper models (`nova-micro`) and only using expensive ones (`claude-opus`) when needed.                                                  |
| **TOOLS AND ACTIONS**                         |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Define tools**                              | Manually handle definitions, schemas, normalization, and validation    | `Tool(function)`                                         | Completed    | You have to manually generate JSON schemas, handle parameter validation, coerce types, format error messages, and ensure your code matches your docs. It's a lot of boilerplate for every single tool.                                                                               | **Zero boilerplate.** Just wrap any Python function with `Tool(my_function)`. The system automatically turns docstrings into descriptions and type hints into JSON schemas. Sync and async are both supported.                                                                                                                 |
| **External services**                         | Build custom integrations per API                                      | Use MCP, official SDKs, or direct API calls              | Completed    | Every external service is a new integration project. You have to write custom clients, handle authentication, manage errors, and maintain tests for every single API you want your agent to use.                                                                                     | Tap into the growing library of MCP-compatible servers (GitHub, Slack, Google Drive) with one line. Or, just wrap any Python function that uses an official SDK or direct HTTP calls and expose it as a tool.                                                                                                                  |
| **Use bash and CLI tools**                    | Spawn sandbox containers or Lambda functions                           | Native local execution                                   | Completed    | To let an agent run a simple command like `git` or `ffmpeg`, you have to spin up a secure sandbox container or a Lambda function. You end up managing full infrastructure stacks just to run basic shell utilities.                                                                  | Agents can natively execute shell commands (`git`, `curl`, `nmap`) and Python scripts within their isolated environment. Need a specific tool like `ffmpeg`? Just install it in your Docker image and it's instantly available to all agents.                                                                                  |
| **Multi-tenant tools**                        | Manually build isolation                                               | ToolFactory                                              | Completed    | Building multi-tenant tools requires implementing logic to swap credentials, manage connection pools, and enforce boundaries for every request. It's error-prone and requires strict auditing to prevent data leaks between tenants.                                                 | **Isolation by design.** Just implement a `create_tools(scope, ...)` factory. The framework calls it for every request, injecting the correct scope (tenant ID) automatically. Each tenant gets a pristine, isolated instance of the tool with the right credentials.                                                          |
| **Human-in-the-loop**                         | Manually handle pause for input                                        | Native `ask_user_for_input` tool                         | Completed    | Implementing "pause for input" requires complex state management: persisting the conversation, setting timeouts, handling resumption tokens, and restoring the full context when the user finally responds maybe days later.                                                         | **Just enable the tool.** Set `enable_ask_for_user_input=True`. The agent automatically pauses execution, saves state, and waits. When the user responds, it resumes exactly where it left off. No custom state machine code required.                                                                                         |
| **Parallel tool execution**                   | Set up Step Functions to fan out                                       | Built-in parallel tool calls                             | Completed    | Running multiple tools in parallel (e.g., searching three different databases) requires orchestrating fan-out logic, handling partial failures, and aggregating results manually. It's often easier to just run them sequentially, which makes agents slow.                          | Autonomy agents automatically invoke tools in parallel. Async tools run simultaneously, reducing latency significantly without any extra coordination code.                                                                                                                                                                    |
| **Distributed tool execution**                | Configure Kubernetes affinity & scheduling                             | Automatic clustering & filtering                         | Completed    | Distributing tool execution across a cluster requires managing Kubernetes node affinity, tolerations, and custom scheduling logic. You have to handle service discovery and tool availability manually to ensure tools run on the right machines.                                    | **It's simple to discover and distribute tool calls.** `clones: 5` creates 5 pods on separate machines. `runner_filter="role=worker,cpu=high"` selects nodes. `Zone.nodes(node, filter="runner")` discovers. Auto-clustering handles the rest.                                                                                 |
| **IDENTITY AND TRUST**                        |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Workload identity**                         | SPIFFE, X.509, service accounts                                        | Ockam Identity                                           | Completed    | Build attestation flows, manage rotation, handle bootstrapping, integrate multiple identity systems.                                                                                                                                                                                 | Every agent gets cryptographic identity at birth. Every message carries identity. Using robust primitives (Noise XX, Ed25519, ECDSA). Formally verified and Trail of Bits audited.                                                                                                                                             |
| **Mutual authentication**                     | mTLS with Istio/Linkerd                                                | Ockam Secure Channels                                    | Completed    | Manage certificate authorities, handle cert lifecycle, configure trust domains, deal with proxy termination, monitor expiration.                                                                                                                                                     | End-to-end mutual authentication at message level. No proxy termination. Identity travels with every message. Resilient across network interruptions.                                                                                                                                                                          |
| **Authorization**                             | Deploy Policy Engines (OPA/Kyverno)                                    | Built-in Attribute-based access control (ABAC)           | Completed    | To get fine-grained auth, you have to deploy and manage policy engines like OPA, write Rego policies, integrate sidecars for enforcement, and keep policy data synced across your fleet. It's a whole separate infrastructure layer to maintain.                                     | **No extra infra.** ABAC is native to Autonomy. Policies are enforced automatically on every message based on the sender's identity attributes. No sidecars, no policy servers, no sync issues.                                                                                                                                |
| **Trust boundaries**                          | VPC, security groups                                                   | Identity-based                                           | Completed    | Trust requires network position. VPC peering, security group rules, NACLs. Trust model breaks across cloud boundaries.                                                                                                                                                               | Cryptographic trust, not topological. Portals connect by identity, not IP. Trust works identically across clouds, networks, organizations.                                                                                                                                                                                     |
| **Encryption in transit**                     | TLS / mTLS                                                             | End-to-end encryption is default                         | Completed    | Trust requires managing certificates per service, handling rotation, and ensuring compliance. Trust boundaries break whenever you leave your private network or cross cloud boundaries.                                                                                              | Ockam Secure Channels end-to-end encrypt from sender to receiver using AES-GCM or ChaChaPoly1305. No certificate management. Formally verified.                                                                                                                                                                                |
| **Secrets**                                   | Vault, Secrets Manager                                                 | secrets.yaml                                             | Completed    | Build injection mechanisms, implement rotation, configure audit logging, integrate different per platform, manage access policies.                                                                                                                                                   | **All secrets are safely managed.** Define in `secrets.yaml`: `API_KEY: "sk-..."`. Reference as `secrets.API_KEY` in `autonomy.yaml`. Supports environment variable injection.                                                                                                                                                 |
| **Tenant isolation**                          | Build complex infra & code isolation                                   | Automatic using `scope` and `conversation`               | Completed    | Isolation requires work at the infrastructure layer (namespaces, network policies, database users, sandboxes) and the code layer (schemas, logic checks). Keeping these in sync to prevent data leaks is a constant operational burden.                                              | **Isolation is automatic.** Just pass `scope="tenant-123"` or `conversation="chat-456"`. The system automatically partitions all state (memory, filesystem, knowledge, tools, and shell sessions) ensuring strict boundaries across tenants.                                                                                   |
| **Agent-to-agent auth**                       | Assemble complex protocols                                             | Native identity, authentication, and access control      | Completed    | Protocols like OAuth were designed for humans delegating to apps, not autonomous agents acting on behalf of a company. Cobbling together OAuth, MCP, and custom auth flows to make agents trust each other is fragile and insecure.                                                  | **Agents are first-class identities.** Every agent has a cryptographic identity at birth. They authenticate and authorize each other natively using their identities.                                                                                                                                                          |
| **OPERATIONS AND DEVELOPER EXPERIENCE**       |                                                                        |                                                          |              |                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                |
| **Deployment**                                | Build complex CI/CD pipelines                                          | `autonomy deploy`                                        | Completed    | Deployment requires stitching together CI runners, container registries, and CD tools (ArgoCD, Flux). You have to write scripts to version artifacts, manage rollouts, and handle rollbacks manually.                                                                                | **One command to production.** `autonomy deploy` automatically builds your agent image, pushes it to your registry, and updates your zone. Simple GitHub Actions workflows can be configured so that when you `git push`, a new version of your application is automatically deployed to production.                           |
| **Configuration**                             | Complex manifests (Helm, K8s, Terraform)                               | Simple `autonomy.yaml`                                   | Completed    | Managing hundreds of YAML manifests, Helm charts, and Terraform state files requires a team of full-time DevOps engineers with deep expertise to handle drift, versioning, and validation.                                                                                           | **Human-readable config.** A single `autonomy.yaml` defines everything. Just set `size: big` for more compute or `public: true` for an HTTPS endpoint. It's simple and doesn't need a DevOps team.                                                                                                                             |
| **Autoscaling**                               | Tune Kubernetes Autoscalers (HPA/VPA)                                  | `clones: N`                                              | Completed    | Configuring Kubernetes Horizontal Pod Autoscalers (HPA) requires constant tuning of CPU/memory thresholds, metrics scraping, and node pool management. Getting it wrong means slow scale-up or wasted money.                                                                         | **One line of config.** Just set `clones: 5` to run 5 instances on separate machines, or change it dynamically. Agents automatically discover their peers across the cluster using `Zone.nodes()`. No complex tuning required.                                                                                                 |
| **Observability unit**                        | Pod / Lambda / Container                                               | Agent / Actor                                            | Completed    | You have to manually stitch together distributed traces across microservices to understand what a single agent did.                                                                                                                                                                  | See full execution traces and agent transcripts: reasoning, tool calls, state transitions, memory access, and sub-agent delegations.                                                                                                                                                                                           |
| **Logging**                                   | Maintain log shippers & aggregators                                    | Zero-config distributed logging                          | Completed    | You have to deploy log shippers (Fluentd), manage expensive storage (ELK/CloudWatch), configure retention policies, and deal with high-volume log ingestion. It's an entire subsystem to manage and pay for.                                                                         | **Logging is built-in.** Distributed, structured logs are automatically collected from every agent across the cluster. View real-time streaming logs for the whole zone in your browser or on the command line using `autonomy logs`.                                                                                          |
| **Local development**                         | Approximations & Mocks                                                 | Local runtime + Production reach                         | Completed    | Local dev is painful because you can't access private cloud resources (DBs, internal APIs) from your laptop. You rely on mocks or approximations, leading to "works on my machine" bugs.                                                                                             | Spin up your apps locally using `autonomy develop` while securely connecting to real private infrastructure in zones on Autonomy Computer using Ockam Portals. This infrastructure includes model gateways, DBs, tools, and other services.                                                                                    |
| **Getting started**                           | Weeks of infra setup                                                   | Just type `autonomy`                                     | Completed    | Learn Kubernetes, networking, CI/CD, service mesh, secrets management, observability stack. Months before first production agent.                                                                                                                                                    | No infrastructure knowledge required. Your first app can be live with a public URL in under 10 minutes. Documentation designed for coding agents. Vibe-code your way to production.                                                                                                                                            |
| **Eval and testing**                          | Build custom eval harness                                              | Agent transcripts and automated testing tools            | Completed    | Testing probabilistic software is hard. You have to build custom harnesses to run tests repeatedly, collect stats, and integrate with CI. Debugging requires manually digging for logs to understand why a test failed.                                                              | **Controlled iterative refinement.** Autonomy exposes rich transcripts and traces that plug into any eval tool. Built-in test runners support probabilistic testing—run a scenario 50 times, measure the pass rate, and break the build only if it drops. This separates successful products from demoware.                    |
| **Production traces**                         | Build tracing & storage infra                                          | Built-in agent and decision traces                       | Completed    | Capturing the "why" behind an agent's decision requires building a custom tracing pipeline, massive storage for high-volume logs, and a query interface to find needle-in-haystack failures.                                                                                         | **The feedback loop is built-in.** Every production decision is traced automatically. See exactly why an agent took an action, find failures, turn them into test cases, and improve. This data is the foundation of your "context graph."                                                                                     |