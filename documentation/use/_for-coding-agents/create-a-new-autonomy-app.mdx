---
title: "Coding Agents: How to create and deploy a new Autonomy app"
description: "Create an new Autonomy app with an agent and a simple streaming chat web interface for this agent. This guide covers the file structure, basic configuration, Docker setup, and other steps to deploy this new app."
---

# A guide for coding agents to create and deploy a new Autonomy app

Use the **Autonomy Framework** to build autonomous AI applications and deploy them on **Autonomy Computer** using **Autonomy Command**.

> **Key Terms**: See the [main guide](https://autonomy.computer/docs/_f.md#definitions) for definitions of **Autonomy**, **Autonomy Framework**, **Autonomy Computer**, **Autonomy Command**, **Agents**, **Models**, **Tools**, and **Memory**.

**Keywords:** setup, hello world, installation, first app, deployment, autonomy.yaml, docker

This guide will:

- Create an initial minimal setup and file structure
- Install and configure the Autonomy Command
- Create the required configuration files
- Create an new app with an agent and a simple streaming chat interface for this agent
- Deploy this new app to the Autonomy Computer
- Test and access your deployed app
- See logs of the deployed app

## Create and deploy a new Autonomy app

### Step 1: Create a new directory for the app

Pick a name for the app and its zone, for example `hello`.

Create that new directory and change into it:

```bash
mkdir hello
cd hello
```

All commands related to this app or zone should be run from inside this directory.

### Step 2: Create `autonomy.yaml`

Create `autonomy.yaml` with the following content:

```yaml
name: hello # The zone's name should be less than 10 characters
pods:
  - name: main-pod
    public: true
    containers:
      - name: main
        image: main
```

Unless the user has asked for a different specific name for the app, use `hello`.

**Important**: Zone names must be 10 characters or less.

This defines a Zone in Autonomy Computer where the application will run.

### Step 3: Create `images/main/Dockerfile`

The zone (defined above) has a `main-pod` and this pod has a `main` container which is built using the `main` docker image. This `main` docker image is defined using the docker file at: `images/main/Dockerfile`.

Create `images/main/Dockerfile` with the following content:

```bash
FROM ghcr.io/build-trust/autonomy-python
COPY . .
ENTRYPOINT ["python", "main.py"]

```

### Step 4: Create `images/main/main.py`

The main image's docker file (defined above) starts the main python program defined in the file `images/main/main.py` .

Create `images/main/main.py` with the following content:

```python
from autonomy import Agent, Model, Node


async def main(node):
    await Agent.start(
    node=node,
    name="henry",
    instructions="You are Henry, an expert legal assistant",
    model=Model("claude-sonnet-4-v1")
    )


Node.start(main)

```

### Step 5: Create `images/main/index.html`

The python program in `images/main/main.py` starts an Autonomy Node. The Node by default starts an HTTP server. If `images/main/index.html` is present, the Node's HTTP server will serve it at its root `/` .

Create `images/main/index.html` with the following content:

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
    body {
        margin: 10% 15%;
        line-height: 1.8;
        overflow-y: scroll;
        overflow-x: hidden;
        font: 21px "Courier New", Courier, monospace;
        padding: 0;
    }

    main {
        max-width: 1080px;
        margin: 0 auto;
        padding: 3rem 1rem;
    }

    pre {
        padding-top: 30px;
        box-sizing: border-box;
        white-space: pre-wrap;
        overflow-wrap: break-word;
    }

    textarea {
        width: 100%;
        max-width: 1080px;
        box-sizing: border-box;
        border: 1px solid #e9e9e9;
        border-radius: 5px;
        box-shadow: 2px 2px 10px #f4f4f4;
        font-size: inherit;
        padding: 1rem;
        display: block;
        height: calc(3 * 1.8em + 14.8px);
    }
    </style>
    <title></title>
</head>
<body>
    <main>
    <textarea id="in" autofocus placeholder="How can I help you..."></textarea>
    <pre id="out"></pre>
    <main>

    <script>
    async function appendCharByChar(text, delay = 5) {
        for (const char of text) {
        out.textContent += char;
        await new Promise(resolve => setTimeout(resolve, delay));
        }
    }

    async function processLine(line) {
        if (line.trim()) {
        const parsed = JSON.parse(line);
        for (const message of parsed.messages) {
            if (message && message.content && message.content.text) {
            await appendCharByChar(message.content.text);
            }
        }
        }
    }

    async function send(message) {
        const input = document.getElementById("in");
        input.disabled = true;

        const out = document.getElementById("out");
        out.textContent = "";

        const response = await fetch("/agents/henry?stream=true", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: message }),
        });

        const decoder = new TextDecoder();
        let buffer = "";

        for await (const chunk of response.body) {
        buffer += decoder.decode(chunk, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop();

        if (!out.textContent) input.value = "";
        for (const line of lines) await processLine(line);
        }

        await processLine(buffer);

        input.disabled = false;
        input.focus();
    }

    document.getElementById("in").addEventListener("keydown", async e => {
        if (e.key === "Enter" && !e.shiftKey && !e.target.disabled && e.target.value.trim()) {
        e.preventDefault();
        await send(e.target.value);
        }
    });
    </script>
</body>
</html>
```

Later, when you deploy this zone to the Autonomy Computer, this web page will become available at: `https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/`. Where `${CLUSTER}` and `${ZONE}` represent the name of this app's Cluster and Zone in the Autonomy Computer.

Unless the user has specifically asked for something different, use exactly the above content for `images/main/index.html`

If you do need to generate a new UI, prefer generating streaming output. Refer the following two examples for the structure of the output of interacting with the agent via the API

Here is an example of streaming output from the API:

```
timeout 15s curl --silent --request POST \
--header "Content-Type: application/json" \
--data '{"message":"What are the key elements of a contract?"}' \
"https://a9eb812238f753132652ae09963a05e9-hello.cluster.autonomy.computer/agents/henry?stream=true"
{"scope": "None", "conversation": "None", "messages": [{"content": {"text": "I", "type": "text"}, "phase": "executing", "thinking": false, "tool_calls": [], "role": "assistant"}], "type": "conversation_snippet"}
{"scope": "None", "conversation": "None", "messages": [{"content": {"text": "'ve already", "type": "text"}, "phase": "executing", "thinking": false, "tool_calls": [], "role": "assistant"}], "type": "conversation_snippet"}
...

```

Here's example output of calling the API without streaming:

```
timeout 15s curl --silent --request POST \
--header "Content-Type: application/json" \
--data '{"message":"What is a contract?"}' \
"https://a9eb812238f753132652ae09963a05e9-hello.cluster.autonomy.computer/agents/henry"

[
  {
    "content": {
      "text": "Great question! A contract legally ...",
      "type": "text"
    },
    "phase": "executing",
    "thinking": false,
    "tool_calls": [],
    "role": "assistant"
  }
]
```

At this point the new zone's directory looks should look like this:

```

├── autonomy.yaml
└── images
    └── main
        ├── Dockerfile
        ├── index.html
        └── main.py
```

### Step 6: Confirm that the user has signed up

Before proceeding forward ask the user if they have already created an account with Autonomy.
If not, instruct them to [sign up](https://my.autonomy.computer) so they get a dedicated Cluster in the Autonomy Computer.

Once they have signed up, proceed to the next step.

### Step 7: Install the `autonomy` command

Check if the `autonomy` command is already installed by running `autonomy --version`. If the command is not installed, install it by running the following in a terminal.

```bash
curl -sSfL autonomy.computer/install | bash && . "$HOME/.autonomy/env"
```

You can check that it is successfully installed by running `autonomy --version`. If it is not found, you may need to run `source "$HOME/.autonomy/env"` to make it available.

### Step 8: Ensure docker is installed and running

Before running the `autonomy` command, ensure [Docker](https://www.docker.com/get-started/) is installed and running in your environment. You can check that docker is working correctly by running:

```
docker ps
```

The `autonomy` command uses docker to build docker images and push them to a Zone in a Cluseter in the Autonomy Computer.

### Step 9: Enroll with your Cluster

Enroll your workstation with your Cluster in Autonomy Computer

```
autonomy cluster enroll --no-input
```

This command will block and print a code that your user has to paste into their browser to sign in, remind them to do that. The command will continue once they have signed in.

### Step 10: Deploy the zone

Deploy the zone dedicated to this app as follows:

```
autonomy zone deploy
```

This will display the name of this app's zone and cluster. Take note of those values, you will need them later.

The `autonomy.yaml` file sets `public: true` on the main pod of the app. That instructs the Autonomy Computer to give this app a public api endpoint and cause the interactive web UI defined in `images/main/index.html` to be served from `https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/`

The zone can take up to a minute to be ready to use.

### Step 11: List all agents

Get a list of all running agents by calling the `/agents` endpoint:

```
timeout 15s curl --silent --request GET \
"https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/agents"
```

This will return a JSON array containing information about all agents that are currently running.

### Step 12: Check that the agent is responding

Check that the agent defined in `images/main/main.py` is responding to an api calls:

```
timeout 15s curl --silent --request POST \
--header "Content-Type: application/json" \
--data '{"message":"what is a contract?"}' \
"https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/agents/henry"
```

```
timeout 15s curl --silent --request POST \
--header "Content-Type: application/json" \
--data '{"message":"What is a contract?"}' \
"https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/agents/henry?stream=true"
```

### Step 13: Guide your user to interact with the app in their browser

Try it: `https://${CLUSTER}-${ZONE}.cluster.autonomy.computer/`

### Step 14: See logs

Start the logs server in the background to view streaming logs from your app:

```bash
# Start logs server in background and capture output to get the actual port
autonomy zone inlet --to logs > logs_server.log 2>&1 &
LOGS_PID=$!

# Wait for server to start and extract the port number
sleep 3
LOGS_PORT=$(grep -o "localhost:[0-9]*" logs_server.log | cut -d: -f2 | head -1)
if [ -z "$LOGS_PORT" ]; then
    LOGS_PORT=32101  # fallback to default port
fi

echo "Logs server running on port: $LOGS_PORT"
echo "Logs server PID: $LOGS_PID"
```

**Option 1: View logs in a browser**

```bash
# Open logs in a web browser (shows streaming logs with a nice UI)
open "http://127.0.0.1:$LOGS_PORT"
```

**Option 2: Stream logs in a terminal**

```bash
# Get the dynamic full pod name and stream logs directly on the terminal
POD_NAME=main-pod && \
CONTAINER_NAME=main && \
FULL_POD_NAME=$(timeout 10s curl -s "127.0.0.1:$LOGS_PORT/" | grep -o 'main-pod-[a-z0-9]*-[a-z0-9]*' | head -1) && \
timeout 30s curl -N "127.0.0.1:$LOGS_PORT/pods/$FULL_POD_NAME/containers/$CONTAINER_NAME" | head -50
```

**Stop the logs server when done:**

```bash
# Kill the specific logs server process
kill $LOGS_PID

# Or kill all autonomy inlet processes
pkill -f "autonomy zone inlet"
```

## Next Steps

Take the application further:
- **Build custom APIs**: Follow the [API Development Guide](./custom-apis.mdx)

## Troubleshooting

- **Zone name too long**: Keep it to 10 characters or less
- **Docker not running**: Verify by running `docker ps`
- **Command not found**: Fix by running `source "$HOME/.autonomy/env"`
- **Deployment issues**: Check the logs using a portal to logs server
